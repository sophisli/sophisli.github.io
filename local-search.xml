<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mathematica实现非对易代数计算</title>
    <link href="/2022/09/01/noncommutativealgebra/"/>
    <url>/2022/09/01/noncommutativealgebra/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>这个问题来源于同学一次偶然的提问。一般的符号计算推导会涉及非对易代数，尤其在理论物理中，对易关系是物理系统非常重要的代数结构，在理论物理很多领域都有广泛的应用。不过很多情况下，心算手推可以直接获得简单的对易子的结果，而在实际应用的理论中，复杂的对易子关系就不那么容易看出或者手动计算十分繁琐，所以就有必要利用符号计算软件强大的功能实现这个过程，解放理论学者的双手。当然，功能繁多的mathematica集成了非对易代数的计算模块，实现的格式如下<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-comment">(*mathematica的非对易模块的调用格式，其中“**”表示算符操作*)</span><br><span class="hljs-built_in">Unprotect</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">NonCommutativeMultiply</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-type">A_</span> <span class="hljs-operator">**</span> <span class="hljs-punctuation">(</span><span class="hljs-type">B_</span> <span class="hljs-operator">+</span> <span class="hljs-type">C_</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span> <span class="hljs-operator">+</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-built_in">C</span><br><span class="hljs-punctuation">(</span><span class="hljs-type">B_</span> <span class="hljs-operator">+</span> <span class="hljs-type">C_</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">**</span> <span class="hljs-type">A_</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">B</span> <span class="hljs-operator">**</span> <span class="hljs-variable">A</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">C</span> <span class="hljs-operator">**</span> <span class="hljs-variable">A</span><br><span class="hljs-type">A_</span> <span class="hljs-operator">**</span> <span class="hljs-type">c_</span><span class="hljs-operator">?</span><span class="hljs-built_in">NumberQ</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span><br><span class="hljs-type">c_</span><span class="hljs-operator">?</span><span class="hljs-built_in">NumberQ</span> <span class="hljs-operator">**</span> <span class="hljs-type">A_</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span><br><span class="hljs-type">A_</span> <span class="hljs-operator">**</span> <span class="hljs-punctuation">(</span><span class="hljs-type">B_</span> <span class="hljs-type">c_</span><span class="hljs-operator">?</span><span class="hljs-built_in">NumberQ</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><span class="hljs-punctuation">(</span><span class="hljs-type">A_</span> <span class="hljs-type">c_</span><span class="hljs-operator">?</span><span class="hljs-built_in">NumberQ</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">**</span> <span class="hljs-type">B_</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><span class="hljs-type">A_</span> <span class="hljs-operator">**</span> <span class="hljs-punctuation">(</span><span class="hljs-type">B_</span> <span class="hljs-type">c_Rational</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><span class="hljs-punctuation">(</span><span class="hljs-type">A_</span> <span class="hljs-type">c_Rational</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">**</span> <span class="hljs-type">B_</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><span class="hljs-type">A_</span> <span class="hljs-operator">**</span> <span class="hljs-punctuation">(</span><span class="hljs-type">B_</span> <span class="hljs-type">c_Power</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><span class="hljs-punctuation">(</span><span class="hljs-type">A_</span> <span class="hljs-type">c_Power</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">**</span> <span class="hljs-type">B_</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">c</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span><br><br><span class="hljs-comment">(*定义对易关系的函数*)</span><br><br><span class="hljs-variable">commutator</span><span class="hljs-punctuation">[</span><span class="hljs-type">A_</span><span class="hljs-operator">,</span> <span class="hljs-type">B_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span> <span class="hljs-operator">-</span> <span class="hljs-variable">B</span> <span class="hljs-operator">**</span> <span class="hljs-variable">A</span><br><span class="hljs-comment">(*这里以定义坐标动量对易关系为例*)</span><br><span class="hljs-variable">fundamentalCommutation</span><span class="hljs-punctuation">[</span><span class="hljs-type">expr_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">:=</span> <br> <span class="hljs-built_in">ExpandAll</span><span class="hljs-punctuation">[</span><span class="hljs-variable">expr</span> <span class="hljs-operator">//.</span> <span class="hljs-variable">p</span><span class="hljs-punctuation">[</span><span class="hljs-type">i_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">**</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">[</span><span class="hljs-type">i_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">:&gt;</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">**</span> <span class="hljs-variable">p</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">h</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><br>可以看出不那么简洁，而且有些功能需要重新定义，学习成本很高。所以这里介绍一款mathematica开源插件，彻底解决mathematica非对易计算的痛点。（btw Maple有更为成熟的解决方案，这方面mathematica要逊色一些，这里不多赘述）</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>这款插件叫NCAlgebra，它是基于mathematica的非对易模块开发的，省去了原有mathematica模块非对易代数语言的学习成本和rewheel的过程。</p><h2 id="插件获得与安装"><a href="#插件获得与安装" class="headerlink" title="插件获得与安装"></a>插件获得与安装</h2><p>插件可以在github上直接下载，地址是<a href="https://github.com/NCAlgebra/NC">https://github.com/NCAlgebra/NC</a>。插件作者早在2017年就完成了基本的开发，稳定版5.0可以直接在页面上下载，当然也可以直接clone作者当前的仓库。下载完解压之后会在根目录中看到一个“InstallNCAlgebra.nb”文件，直接用mathematica打开，按照英文指示安装即可。这个note文件实质上隐藏了安装命令。</p><p>插件作者十分细心给出了安装指导，他在note文件中反复强调了最重要的步骤：<strong>把一开始解压的包含note文件的根文件夹名更改为NC</strong>，以便插件集成过程中在mathematica的环境配置。</p><h2 id="插件的使用：计算对易子"><a href="#插件的使用：计算对易子" class="headerlink" title="插件的使用：计算对易子"></a>插件的使用：计算对易子</h2><p>下面介绍插件关于计算对易子的使用<br>这里以计算</p><script type="math/tex; mode=display">\sigma_+=c s R_z+c^2 R_+-s^2 R_-\\\sigma_-=c s R_z-s^2 R_+-c^2 R_-\\\left[\sigma_+\,,\sigma_-\right]=?</script><p>为例。<br>其中基本的对易关系是</p><script type="math/tex; mode=display">[R_z\,\,R_+]=2R_+,\quad[R_z\,\,R_-]=2R_-,\quad[R_+\,\,R_-]=R_z</script><p>调用插件，导入NC模块以及非对易模块：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-comment">(*Import package*)</span><span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">NC</span><span class="hljs-operator">`</span><br><span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">NCAlgebra</span><span class="hljs-operator">`</span><br><span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">NCGBX</span><span class="hljs-operator">`</span><br></code></pre></td></tr></table></figure><br>定义基本对易关系：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-comment">(*约定算符作用的方向和顺序*)</span><br><span class="hljs-variable">SetNonCommutative</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rp</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rm</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rz</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">SetCommutative</span><span class="hljs-punctuation">[</span><span class="hljs-variable">c</span><span class="hljs-operator">,</span> <span class="hljs-variable">s</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">SetMonomialOrder</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rz</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rp</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rm</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">(*x to the left,p to the right*)</span><br><span class="hljs-variable">NCSetOutput</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">NonCommutativeMultiply</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">True</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">(*pretty output*)</span><br><span class="hljs-comment">(*利用NCmakeGB设置基本对易关系的约束 *)</span><br><span class="hljs-variable">gb</span> <span class="hljs-operator">=</span> <span class="hljs-variable">NCMakeGB</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">Rp</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rm</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Rm</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rp</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Rz</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rz</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rp</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Rp</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rz</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span> <span class="hljs-variable">Rp</span><span class="hljs-operator">,</span> <span class="hljs-variable">Rz</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rm</span> <span class="hljs-operator">-</span> <span class="hljs-variable">Rm</span> <span class="hljs-operator">**</span> <span class="hljs-variable">Rz</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-variable">Rm</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-number">20</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><br>和mathematica非对易语法一样,定义对易表达式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Comm</span><span class="hljs-punctuation">[</span><span class="hljs-type">A_</span><span class="hljs-operator">,</span> <span class="hljs-type">B_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">A</span> <span class="hljs-operator">**</span> <span class="hljs-variable">B</span> <span class="hljs-operator">-</span> <span class="hljs-variable">B</span> <span class="hljs-operator">**</span> <span class="hljs-variable">A</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><br>然后便可以通过NC的模块算符操作<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-comment">(*计算对易关系并展开，注意这里NCExpand是算符操作的展开，不要和mathematica自带的expand函数混淆*)</span><br><span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-variable">Comm</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">SubPlus</span><span class="hljs-punctuation">[</span><span class="hljs-variable">\[Sigma]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-built_in">SubMinus</span><span class="hljs-punctuation">[</span><span class="hljs-variable">\[Sigma]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">//</span> <span class="hljs-variable">NCExpand</span><br><span class="hljs-comment">(*对展开的对易式做基本对易关系替换，并把最后的结果展开*)</span><br><span class="hljs-variable">NCReplaceRepeated</span><span class="hljs-punctuation">[</span><span class="hljs-variable">expression</span><span class="hljs-operator">,</span> <span class="hljs-variable">gb</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">//</span> <span class="hljs-variable">NCExpand</span><br></code></pre></td></tr></table></figure><br>不过由于替换函数（在mathematica中是表达式后/.{x-&gt;y})过于傻瓜，只能替换形式一致的符号，所以往往一次替换并不能给出最简单的结果，所以有网友在stackexchange上提出了一个解决方案<a href="#1"><sup>1</sup></a>——就是多替换几次。利用上面的关系式循环嵌套若干次直到最后形式收敛即可。或者按照该网友的方法，定义替换函数，重复调用即可：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">foo</span><span class="hljs-punctuation">[</span><span class="hljs-type">X_</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">NCExpand</span><span class="hljs-operator">@</span><span class="hljs-variable">NCReplaceRepeated</span><span class="hljs-punctuation">[</span><span class="hljs-variable">X</span><span class="hljs-operator">,</span> <span class="hljs-variable">gb</span><span class="hljs-punctuation">]</span><br><span class="hljs-variable">expression</span> <span class="hljs-operator">//</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">//</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">//</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">//</span> <span class="hljs-variable">foo</span><br></code></pre></td></tr></table></figure><br>最后输出的结果是<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">c</span><span class="hljs-operator">^</span><span class="hljs-number">4</span> <span class="hljs-variable">Rz</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-variable">c</span><span class="hljs-operator">^</span><span class="hljs-number">3</span> <span class="hljs-variable">Rm</span> <span class="hljs-variable">s</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span> <span class="hljs-variable">c</span><span class="hljs-operator">^</span><span class="hljs-number">3</span> <span class="hljs-variable">Rp</span> <span class="hljs-variable">s</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span> <span class="hljs-variable">c</span> <span class="hljs-variable">Rm</span> <span class="hljs-variable">s</span><span class="hljs-operator">^</span><span class="hljs-number">3</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span> <span class="hljs-variable">c</span> <span class="hljs-variable">Rp</span> <span class="hljs-variable">s</span><span class="hljs-operator">^</span><span class="hljs-number">3</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Rz</span> <span class="hljs-variable">s</span><span class="hljs-operator">^</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><br>这里需要注意的是，NC的算符识别对有特殊下标的符号不是很友好，所以这里把$R_-$换成了$R_m$，其他同理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mathematica.stackexchange.com/questions/240267/calculating-commutators-in-quantum-mechanics-symbolically-with-the-help-of-mathe"><span id="1">1. https://mathematica.stackexchange.com/questions/240267/calculating-commutators-in-quantum-mechanics-symbolically-with-the-help-of-mathe</span></a></p>]]></content>
    
    
    <categories>
      
      <category>symbol calculation</category>
      
      <category>mathematica</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mathematica一种实现多项式合并化简的方法</title>
    <link href="/2022/08/19/mathematica-ways/"/>
    <url>/2022/08/19/mathematica-ways/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>类似地，当符号计算多项式涉及叠波、频谱分析等的时候，对如下多项式的简化</p><script type="math/tex; mode=display">f(x,a,b,c,d,\cdots)=a e^{-i(bx+d^2)}+a b c e^{-i(bx+d^2x^2+fc^2)}+\cdots+\frac{a^2b^2}{2c+b+d^3} e^{-i(bx+d^2)}</script><p>mathematica的Simplify或factor函数实现的形式并不是我们想要的。<br>实际上我们需要将多项式相同指数项进行合并操作，</p><script type="math/tex; mode=display">f(x,a,b,c,d,\cdots)=(a b c+\cdots) e^{-i(bx+d^2x^2+fc^2)}+\cdots+\left(a+\frac{a^2b^2}{2c+b+d^3}+\cdots\right) e^{-i(bx+d^2)}</script><p>而实际情况下在涉及复杂多项式的对应简化，人工手动选择逐一合并是不现实的，所以本文提出一个解决的方案。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>核心的函数是PotionIndex和映射定义<a href="#1"><sup>1</sup></a>。</p><p>首先将多项式逐项展开成列表形式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">p1expand</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Expand</span><span class="hljs-punctuation">[</span><span class="hljs-variable">p1</span><span class="hljs-punctuation">]</span><span class="hljs-comment">(* p1是如上需要被展开的多项式 *)</span><br><span class="hljs-variable">apply</span><span class="hljs-punctuation">[</span><span class="hljs-variable">list</span><span class="hljs-operator">,</span><span class="hljs-variable">p1expand</span><span class="hljs-punctuation">]</span>       <br></code></pre></td></tr></table></figure><br>有了以上的逐项展开式，我们可以分别对多项式的子项进行操作，由此，可以调用FirstCase函数并创建映射关系，提取列表的每一项的系数和指数信息，并将指数转换成系数矩阵的形式：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">coefflist</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">FirstCase</span><span class="hljs-punctuation">[</span><span class="hljs-type">#</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Exp</span><span class="hljs-punctuation">[</span><span class="hljs-type">b__</span><span class="hljs-punctuation">]</span> <span class="hljs-type">a_</span><span class="hljs-operator">.</span> <span class="hljs-operator">:&gt;</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">a</span><span class="hljs-operator">,</span> <span class="hljs-built_in">CoefficientList</span><span class="hljs-punctuation">[</span> <span class="hljs-variable">b</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span><span class="hljs-variable">c</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-number">0</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">&amp;</span> <span class="hljs-operator">/@</span> <span class="hljs-variable">p1list</span> <span class="hljs-operator">;</span><span class="hljs-comment">(*注意，这里e指数部分的多项式变量是x和c，只是简单示例，类似地，可以定义任意的底数*)</span><br></code></pre></td></tr></table></figure><br>由于实际的多项式指数部分的可能只有常系数，所以转换来的系数矩阵可能是空集，因此我们需要把这部分空集去掉。<br>这里一开始要确定空集的位置：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">nullindex</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Position</span><span class="hljs-punctuation">[</span><span class="hljs-variable">coefflist</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><br>由此获得coefflist去除空集后的列表，进而得到去除空集的元素位置：：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">withoutnull</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Cases</span><span class="hljs-punctuation">[</span><span class="hljs-variable">coefflist</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Except</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">PositionIndex</span><span class="hljs-punctuation">[</span><span class="hljs-variable">withoutnull</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-operator">;;</span> <span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><br>这里使用List结构和循环结构，分别计算系数项，e指数项以及常数项：</p><p>系数项：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">coeff</span><span class="hljs-operator">=</span><span class="hljs-built_in">Table</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Simplify</span><span class="hljs-punctuation">[</span><span class="hljs-variable">withoutnull</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">index</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">//</span> <span class="hljs-built_in">Total</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">i</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">,</span>  <span class="hljs-built_in">Length</span><span class="hljs-punctuation">[</span><span class="hljs-variable">index</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><br>指数项：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">expon</span><span class="hljs-operator">=</span><span class="hljs-built_in">Table</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Simplify</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Internal</span><span class="hljs-operator">`</span><span class="hljs-variable">FromCoefficientList</span><span class="hljs-punctuation">[</span> <span class="hljs-variable">withoutnull</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">waveindex</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span><span class="hljs-variable">c</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">//</span> <span class="hljs-built_in">Exp</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">i</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Length</span><span class="hljs-punctuation">[</span><span class="hljs-variable">index</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><br>  常数项：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Do</span><span class="hljs-punctuation">[</span><span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">+</span> <span class="hljs-variable">p1list</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">nullindex</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">i</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Length</span><span class="hljs-punctuation">[</span><span class="hljs-variable">nullindex</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span>；<br></code></pre></td></tr></table></figure><br>最后只需要<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">poly</span><span class="hljs-operator">=</span><span class="hljs-variable">coeff</span><span class="hljs-operator">.</span><span class="hljs-variable">expon</span><span class="hljs-operator">+</span><span class="hljs-variable">rt</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><br>即可得到最后的归并形式。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span id="1">1. 这是小憩片刻的思路</span></p>]]></content>
    
    
    <categories>
      
      <category>symbol calculation</category>
      
      <category>mathematica</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>machine learning note</title>
    <link href="/2022/08/08/machinelearning/"/>
    <url>/2022/08/08/machinelearning/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>这是几年前机器学习课程的学习笔记。特此记录，持续更新。。。</p><h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><p>回归模型是对已有数据和未知信息的沟通，预测模型本质上是历史数据的函数。寻找一个拟合函数是机器学习或者统计学习的主要目的。注意，这里的拟合函数的获得不同经典的统计学方法，比如最小二乘法，机器学习的回归模型是多参数<br>Sigmoid函数：</p><script type="math/tex; mode=display">f(w,b,c)= c \frac{1}{1+e^{-( b+w x)}}</script><p>原来的线性模型</p><script type="math/tex; mode=display">f(\boldsymbol{x})=b+\sum_i w_ix_i</script><p>可以换成</p><script type="math/tex; mode=display">f(\boldsymbol x)=b+\sum_{i}c_i \mathrm{Sigmoid}(b_i+\sum_{ij}w_{ij}x_j)</script><p><img src="http://tva1.sinaimg.cn/large/006fyIojgy1h50l8yf0kaj30rn0ko0zk.jpg" alt="线性模型中Sigmoid函数作为激活函数"><br>用矩阵写出</p><script type="math/tex; mode=display">f(\boldsymbol x)=b+c^T\sigma(\boldsymbol b+W \boldsymbol x)</script><p>其中$\sigma$是激活函数，$\theta$显然是模型中所有未知的参数。<br>以上过程可以重复进行，示意图的结构就变成了多层，构成了所谓的人工神经网络。在一些例子中模型层数的增加会显著优化预测数据的准确度，降低loss函数的误差。最终发展出了所谓的深度学习框架（Deep Learning）</p><h2 id="确定损失函数-L-theta"><a href="#确定损失函数-L-theta" class="headerlink" title="确定损失函数$L(\theta)$"></a>确定损失函数$L(\theta)$</h2><p>我们实际上是想确定一个$\theta$使得损失函数最小：</p><script type="math/tex; mode=display">\theta'=\mathrm{arg}\,min_{\theta}(L)</script><h3 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h3><h2 id="贝叶斯统计"><a href="#贝叶斯统计" class="headerlink" title="贝叶斯统计"></a>贝叶斯统计</h2><h2 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h2><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h1 id="深度学习初步"><a href="#深度学习初步" class="headerlink" title="深度学习初步"></a>深度学习初步</h1>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gauge in physics: a learning note from classical electromagnetics to gauge field theory</title>
    <link href="/2022/06/26/Gauge-in-physics-a-learning-note-from-classical-electromagnetics-to-gauge-field-theory/"/>
    <url>/2022/06/26/Gauge-in-physics-a-learning-note-from-classical-electromagnetics-to-gauge-field-theory/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Classical-gauge-Selecting-Magnetical-Vector"><a href="#Classical-gauge-Selecting-Magnetical-Vector" class="headerlink" title="Classical gauge: Selecting Magnetical Vector"></a>Classical gauge: Selecting Magnetical Vector</h1><h1 id="theoretical-mechanic-frame-the-principle-of-least-action-to-Noether-theorem"><a href="#theoretical-mechanic-frame-the-principle-of-least-action-to-Noether-theorem" class="headerlink" title="theoretical mechanic frame: the principle of least action to Noether theorem"></a>theoretical mechanic frame: the principle of least action to Noether theorem</h1><h1 id="The-beginning-of-latice-gauge-field-theory-Bloch-Floquet-theory"><a href="#The-beginning-of-latice-gauge-field-theory-Bloch-Floquet-theory" class="headerlink" title="The beginning of latice gauge field theory: Bloch Floquet theory"></a>The beginning of latice gauge field theory: Bloch Floquet theory</h1><h2 id="spinor-and-Chiral"><a href="#spinor-and-Chiral" class="headerlink" title="spinor and Chiral"></a>spinor and Chiral</h2><h2 id="Berry-gauge"><a href="#Berry-gauge" class="headerlink" title="Berry gauge"></a>Berry gauge</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>the routing of English learning</title>
    <link href="/2022/06/23/the-routing-of-English-learning/"/>
    <url>/2022/06/23/the-routing-of-English-learning/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>还在总结中，敬请期待。。。</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>这是一个关于本人多年外语学习的系统性总结。作为资深的外语学习者，多年的英语学习经历促成了这个总结的诞生，而外语学习俨然变成了一种人生的态度。故而为过往的尝试梳理出一份更有参考价值的学习路线和方法，希望能给需要的人提供启发。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="心理准备"><a href="#心理准备" class="headerlink" title="心理准备"></a>心理准备</h2><h3 id="信心"><a href="#信心" class="headerlink" title="信心"></a>信心</h3><h3 id="持续的热情"><a href="#持续的热情" class="headerlink" title="持续的热情"></a>持续的热情</h3><h3 id="树立终生学习的态度"><a href="#树立终生学习的态度" class="headerlink" title="树立终生学习的态度"></a>树立终生学习的态度</h3><h3 id="设立目标和任务量"><a href="#设立目标和任务量" class="headerlink" title="设立目标和任务量"></a>设立目标和任务量</h3><h3 id="物质准备"><a href="#物质准备" class="headerlink" title="物质准备"></a>物质准备</h3><h1 id="发音练习"><a href="#发音练习" class="headerlink" title="发音练习"></a>发音练习</h1><h2 id="国际音标-IPA-强化学习"><a href="#国际音标-IPA-强化学习" class="headerlink" title="国际音标(IPA)强化学习"></a>国际音标(IPA)强化学习</h2><h2 id="歌曲台词练习"><a href="#歌曲台词练习" class="headerlink" title="歌曲台词练习"></a>歌曲台词练习</h2><h1 id="听力练习"><a href="#听力练习" class="headerlink" title="听力练习"></a>听力练习</h1><h2 id="Couch-Shane-amp-空中课堂-amp-TV-series-amp-艾伦秀"><a href="#Couch-Shane-amp-空中课堂-amp-TV-series-amp-艾伦秀" class="headerlink" title="Couch Shane&amp;空中课堂&amp;TV series&amp;艾伦秀"></a>Couch Shane&amp;空中课堂&amp;TV series&amp;艾伦秀</h2><h1 id="语法初步"><a href="#语法初步" class="headerlink" title="语法初步"></a>语法初步</h1><h2 id="赖世雄语法"><a href="#赖世雄语法" class="headerlink" title="赖世雄语法"></a>赖世雄语法</h2><h1 id="词根词缀词源（单词强化）"><a href="#词根词缀词源（单词强化）" class="headerlink" title="词根词缀词源（单词强化）"></a>词根词缀词源（单词强化）</h1><h2 id="两本书"><a href="#两本书" class="headerlink" title="两本书"></a>两本书</h2><h2 id="百度翻译app词汇打卡"><a href="#百度翻译app词汇打卡" class="headerlink" title="百度翻译app词汇打卡"></a>百度翻译app词汇打卡</h2><h1 id="保持实战（测试）"><a href="#保持实战（测试）" class="headerlink" title="保持实战（测试）"></a>保持实战（测试）</h1>]]></content>
    
    
    <categories>
      
      <category>lifelong learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统下Fortran编译和链接第三方库</title>
    <link href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8BFortran%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <url>/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8BFortran%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;初学者通常会在Windows系统上通过IDE编译运行Fortran程序，然而，涉及大型计算以及多线程并行过程，Fortran的应用场景是在集群和超算上，就需要考虑在Linux系统编译和链接MKL和MPI这些基础的第三方计算库。由于linux上习惯上不使用图形化界面，一般的编译过程以命令行的形式显示，所以需要掌握一些手动编译的操作。以下仅给出一个笔者实操的解决方案。</p><p>P.S. 本文所有方案基于主流的Intel Visual Fortran(IVF)编译环境，默认你的操作系统已安装 </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="Linux系统上Fortran编译运行基础"><a href="#Linux系统上Fortran编译运行基础" class="headerlink" title="Linux系统上Fortran编译运行基础"></a>Linux系统上Fortran编译运行基础</h2><h3 id="编译和链接命令"><a href="#编译和链接命令" class="headerlink" title="编译和链接命令"></a>编译和链接命令</h3><p>&emsp;&emsp;作为一门解释型语言，Fortran的运行需要编译已有代码并链接各种运行时库对应第三方库才能建立机器码可执行文件（即.exe文件），所以完成整个运行过程需要掌握相应的编译和链接命令。</p><p><strong>IVF的编译命令</strong>：ifort [options] file1 [file2 …]</p><p>此处options如果为“-c”意为compile，即编译；“-o”则是根据对象文件生成可执行文件，即object的首字母缩写；“-g”为generate，生成；“-L”为link，链接之意，主要用于指定并链接第三方库；“-I”为include，用于指定编译Fortran代码的标准文件，不同的第三方库都有对应的include地址和标准文件。我们主要用到以上几种编译命令。实际的编译运行过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifort -c example1.f90 example2.f90 ...<br>ifort example1.o example2.o ...  -o yourProgramName<br></code></pre></td></tr></table></figure><p>这里需要注意你的程序文件之间相互的依赖性，“-c”编译生成object（.o）文件的过程是严格遵循依赖优先级的，例如，这里example2.f90需要调用example1.f90，它们的顺序不能颠倒。</p><h3 id="静态库和动态库1"><a href="#静态库和动态库1" class="headerlink" title="静态库和动态库1"></a>静态库和动态库<a href="#1"><sup>1</sup></a></h3><p>简要说明二者的区别。</p><p>（1）按照操作系统的不同有以下后缀名不同的两类</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">win32平台下，静态库后缀一般为.lib,动态库为.dll<br>linux平台下，静态库后缀一般为.a,动态库为.so<br></code></pre></td></tr></table></figure><p>（2）按照链接过程的不同区分静态库和动态库：</p><p>&emsp;&emsp;静态库是在程序编译的过程中链接到目标代码，而动态库则是在程序运行的过程中载入内存参与程序的运行。可见静态库的链接过程会增加可执行程序的体积，相应增强了程序的可移植性，因为目标代码在编译链接静态库之后生成的可执行文件不再依赖系统运行环境的设置。而调用动态库，无需在程序编译的时候链接库文件，从而可以在程序运行时随时替换对应动态库，只需要保证程序运行的过程能找到动态库文件即可，方便程序后期的升级和扩展。</p><h3 id="链接第三方库"><a href="#链接第三方库" class="headerlink" title="链接第三方库"></a>链接第三方库</h3><p>&emsp;&emsp;我们可以使用“-l”命令完成静态库的链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifort -o example1.o example2.o -I$(your Include<span class="hljs-string">&#x27;s Direction ) -L$(your Lib&#x27;</span>s Direction)$(the required lib-file)<br></code></pre></td></tr></table></figure><p>通过如上操作，便可以将存在第三方库依赖的程序进行编译链接并生成可执行文件。</p><p>&emsp;&emsp;综上可以看出，如果涉及编译一个较为复杂的工程，则需要大量的手动输入，在实际编译过程中是很不方便的，所以我们需要用到makefile对这些文件统一处理。</p><h2 id="建立一个makefile文件，统一处理编译和链接过程"><a href="#建立一个makefile文件，统一处理编译和链接过程" class="headerlink" title="建立一个makefile文件，统一处理编译和链接过程"></a>建立一个makefile文件，统一处理编译和链接过程</h2><p>&emsp;&emsp;在Linux系统上为了简化Fortran和C这些解释型语言的编译过程，一个成熟的解决方案是make统一编译。这里给出一个示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mkllib=/public/home/users/app/compiler/intel-2017.8/compilers_and_libraries_2017.8.262/linux/mkl/lib/intel64 <br>mklinc=/public/home/users/app/compiler/intel-2017.8/compilers_and_libraries_2017.8.262/linux/mkl/<span class="hljs-keyword">include</span><br>mpilib=/public/home/users/app/compiler/intel-2017.8/compilers_and_libraries_2017.8.262/linux/mpi/lib64<br>mpiinc=/public/home/users/app/compiler/intel-2017.8/compilers_and_libraries_2017.8.262/linux/mpi/include64<br>FCCFLAG=-lmkl_lapack95_lp64 <br>FCC=mpiifort<br><br><span class="hljs-section">origin:origin.f90 nrtype.o nrutil.o</span><br><span class="hljs-variable">$(FCC)</span> -o bulk origin.f90 nrtype.o nrutil.o -I<span class="hljs-variable">$(mklinc)</span> -I<span class="hljs-variable">$(mpiinc)</span> -L<span class="hljs-variable">$(mkllib)</span> <span class="hljs-variable">$(FCCFLAG)</span> <span class="hljs-variable">$(mpilib)</span>/libmpi.a  -mkl<br><span class="hljs-section">nrtype.o:nrtype.f90</span><br><span class="hljs-variable">$(FCC)</span> nrtype.f90 -c <br><span class="hljs-section">nrutil.o:nrutil.f90</span><br><span class="hljs-variable">$(FCC)</span> nrutil.f90 -c<br><span class="hljs-section">clean:</span><br>rm -f *.o origin<br>rm -f *.mod origin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;Makefile是Linux系统下的一种编译脚本，make的用法这里不做具体展开，具体可以参考B站的视频<a href="#2"><sup>2</sup></a>。这里的makefile主要包含Intel计算库MKL以及并行计算库MPI的路径和对应include的位置，视已安装库文件的具体路径而定。数学库IntelMKL和并行计算库IntelMPI是科学计算中常用的第三方库，所以以此为例，做简要说明。</p><p>&emsp;&emsp;本人这里使用了MKL lapack95的函数库，所以在库文件调用一栏填写的是“-lmkl_lapack95_lp64 ”，这个依据实际编程需要的库而定，在调用MKL的情况下还需要在编译命令一栏后加上“-mkl”命令，才能完成最终的编译。而链接并行计算的库文件则是“libmpi.a”这个静态库文件。如makefile文件所示，引用多个库的标准文件和库文件可以分别写在一起，同时连接编译，这里不用考虑前后顺序。</p><p>&emsp;&emsp;需要注意的是，由于程序用到了并行计算，所以实际的编译命令“ifort”需要改成“mpiifort”。</p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://blog.51cto.com/u_12444109/3032520"><span id="1">1. https://blog.51cto.com/u_12444109/3032520</span></a></p><p><a href="https://www.bilibili.com/video/BV1Mx411m7fm?spm_id_from=333.337.search-card.all.click&amp;vd_source=7ffaf781bf9e178e533a627b572b618b"><span id="2">2. https://www.bilibili.com/video/BV1Mx411m7fm?spm_id_from=333.337.search-card.all.click&amp;vd_source=7ffaf781bf9e178e533a627b572b618b</span></a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Fortran</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Notices in deploying Intel MKL and MPI in VS environment</title>
    <link href="/2022/04/20/Notice-in-deploying-Intel-MKL-environment/"/>
    <url>/2022/04/20/Notice-in-deploying-Intel-MKL-environment/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>“遇到一些bug，尤其像Fortran这种老旧的语言，多半会让人像斯金纳的鸽子，迷信式祈祷自己不要遇到这些问题。但现实永远像墨菲定律，所以你需要熟悉这些基本操作<sup><a href="#1">1</a></sup>。”</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在Visual Studio(VS)上配置Intel Visual Fortran并调用MKL这种计算库，实际上会遇到一些莫名其妙的问题，这里主要记录一些踩坑的经历。</p><h1 id="oneAPI-or-Intel-Parallel-Studio-XE-in-VS"><a href="#oneAPI-or-Intel-Parallel-Studio-XE-in-VS" class="headerlink" title="oneAPI or Intel Parallel Studio XE in VS"></a>oneAPI or Intel Parallel Studio XE in VS</h1><p>目前主流的Fortran编译环境是Intel旗下的Intel Visual Fortran，主要集成在parallel studio或者现在的oneAPI中，这里基础套件的安装过程就不再详述，具体参看<a href="https://www.intel.cn/content/www/cn/zh/developer/tools/oneapi/toolkits.html#gs.47d8mh">官网</a>的介绍。问题集中在VS 的配置上，所以以下详细介绍整个配置过程。</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>安装完oneAPI的基础套件或者旧版本的Parallel Studio之后，Fortran的编译环境会自动集成到VS上，就能在VS界面的菜单栏新建项目里找到相应的开发选项。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sg9gmmoej30rw0bjwjs.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;"> 红框中显示了IDE界面下的Fortran的开发选项</div> </center>集成开发环境可以很方便把Fortran的编写纳入VS的工作流。### MKL和MPI的配置像Fortran这类面向过程的编译型语言，其编译实现需要编译器将写好的目标代码转换为中间代码，链接器将此中间代码与其他代码相结合生成可执行文件(.exe后缀，即二进制机器码)。编译部分是编译器对源代码的检查和转换，而链接过程就是把转换之后的源代码和系统的标准启动代码以及库代码结合在一起，形成最终的可执行文件。<span id="#console"> </span><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5skl2f045j3071052dgv.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;"> 在win系统平台，Fortran的文件目录下编译过程会涉及图中几种后缀的文件生成。</div> </center>注意到，除了一些可执行文件的修饰文件和日志文件，上图展示的是一个叫Console4的项目编译生成了.obj、.mod、.exe这三种后缀的文件。.exe是可执行文件，.mod即module模块文件，.obj是object的缩写，即工程文件，也就是刚才提到的中间文件，它是链接器操作的对象。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sl8qrm8mj30lq0103zj.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">作为对比，在超算集群Linux平台下的编译文件和win平台略微有所区别</div> </center>和win平台有所区别的是，Linux下工程文件从.obj后缀变成了.o后缀，可执行文件没有后缀名（图中绿色显示）。## 项目配置在经过<a href="#console">第一节</a>的新建开发项目之后，我们需要对新建的项目做相应的配置。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sojsxdwpj30k30f344j.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">在VS界面可以找到解决方案一栏，这里有详细的项目文件层级，只需要选定任意项目名称右键即可在属性选项下找到项目配置的页面。</div> </center>可选择地，<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5soktmonmj30ik08un08.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">菜单栏项目下亦可找到该项目属性选项。</div> </center><h3 id="属性页面的设置"><a href="#属性页面的设置" class="headerlink" title="属性页面的设置"></a>属性页面的设置</h3><p>属性页面是一系列涉及项目源码编译的选项，也是VS作为一个著名的集成开发平台在项目管理上的便易性体现，如果单纯通过命令行展开项目开发，将会是一个相当繁杂而艰难的任务。经过一定的项目配置，可以傻瓜式地实现一个大型项目的开发和编译过程。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5soslapejj30oe0brtdd.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">项目编译的若干选项设置。</div> </center>可以看到项目属性页左侧集成了Fortran编译和调试的各种选项设置。其中General是编译输出位置和输出名设置等基本编译操作，而debuging一项则是调试的基本设置。我们重点关注的是Fortran编译器和Linker链接器的设置，尤其关于第三方库的配置。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5spcef7xbj30nq03gmyn.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">配置选项和平台。</div> </center>而属性页面上方是平台配置，出现了Debug和Release以及平台架构的选择，这也是初学者很容易在IDE设置上混淆的地方。### Debug和Release“Debug”，顾名思义，调试，是编译过程重要的步骤，而“Release”即发布，是调试结束后的事。之所以配置选项专门给了debug和release这两种设置，也是意在把调试任务和程序最终的发布区分开。因此，如果配置器选择了Debug，整个编译过程会额外地记录编译的细节，以便调试程序的运行。换句话说，Debug的配置器会把调试放在第一位，包括我们可能需要的单步断定调试或异步调试，这些都依赖Debug配置下的设置。而Release配置器则倾向于程序稳定运行和移植，所以会裁除调试信息，降低程序冗余，以便开发者发布最终的成品。<center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sq20vrsnj30990323z1.jpg">     <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sq35xavbj307s03hglz.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">Debug的生成文件大小在同样配置下要远大于Release。</div> </center><h3 id="编译器的选项设置"><a href="#编译器的选项设置" class="headerlink" title="编译器的选项设置"></a>编译器的选项设置</h3><p><strong>Fortran选项一栏：</strong><br>在Fortran选项下有以下需要注意的地方。对于General一项，主要涉及一些调试优化，对于不同配置器，这些优化选项有必要区分。我们需要关注的是下图箭头指向的两项，对于Release配置器，大可不必做调试，优化也可选择速度最优，以节省计算机编译和执行的时间。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sp65ddrij30np0eb43i.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">Fortran选项下General一项需要注意箭头指向的设置。</div> </center>对于Libaries一项，则需要注意另外两个地方。运行时库的选择如果如图所示，可以大大降低程序的体积，因为这里选择的库文件类型是动态库类型，在<a href="https://sophisli.github.io/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8BFortran%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">Linux系统下Fortran编译和链接第三方库</a>一文中，我简单提到过这个特点，对于调用动态库，无需将所需要的库文件集成到可执行文件中。从而可以降低可执行文件的体积。另外需要注意的是，Intel的数学核心库调用要选择为并行版本。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sp2xyy4gj30nj0ecafe.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">Fortran选项下Liberies一项需要注意箭头指向的设置。</div> </center><p><strong>Linker选项一栏：</strong><br>Linker链接器选项设置仍然需要注意两个地方，第一就是input选项下附加依赖项要键入<code>mkl_lapack95_ilp64.lib impi.lib</code>。这里要稍加解释，因为网上一部分方案都是以讹传讹的设置，盲目地参考这些教程键入奇怪的库文件名会导致难以排查的编译错误。这里我仅仅需要这两项就可以完成MKL和MPI库的调用，而我需要lapack95计算包的函数以及实现并行计算的任务。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sqs0d17hj30nn0faafg.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">Linker选项下Input一项需要注意箭头指向的设置。</div> </center><p>另外，在system选项下，同样是第一项需要选择“console”</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sr4xn5cpj30ne0fa0xu.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">子系统需要选择console，以匹配系统程序启动入口。</div> </center>不然会出现没有定义程序入口点的错误。<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sr6romixj30rc02pjsb.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">这个错误相当低级，但是对于初学者是致命的，因为很难检索到解决方案。</div> </center><h3 id="区分编译平台"><a href="#区分编译平台" class="headerlink" title="区分编译平台"></a>区分编译平台</h3><p>这里涉及32位平台和64位平台的选择问题，稍懂计算机的都知道这里“位”是信息的单位，CPU在早期有32位架构，一部分早期的计算机语言在编译处理上就遗留了寄存器信息处理位宽的历史问题。所以对于Fortran而言，一部分早期可靠的源代码依赖32位平台的处理，而后来源码的编译都是在更先进信息吞吐量更大的64位架构的计算机上完成的，同样也遗留了编译平台的问题。这些底层的代码决定了有些运行库对编译平台有特别的要求，比如IntelMPI的库文件就只能在64位平台下编译运行，不清楚这些问题，错选32位平台，会出现难以排查的编译问题。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5srdxqxmhj30jo09bjtl.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">可以通过箭头所指设置不同配置器的架构，一般是win32和x64。</div> </center><h2 id="VS上的一些重要设置"><a href="#VS上的一些重要设置" class="headerlink" title="VS上的一些重要设置"></a>VS上的一些重要设置</h2><p>说了这么多项目配置，实质上一开始我们还需要熟悉VS基本的设置，它涉及Fortran第三方库调用的环境配置。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5srnu0gk3j30mh0k7woe.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">在菜单栏“工具”下找到选项，在Intel编译工具下可以找到编译器设置，这里我们需要设置头文件地址和库文件地址，对应箭头所示</div> </center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5srsnhl2ej30nn06ojus.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">Intel套件安装位置可以找到头文件地址和库文件地址。图示是MKL的头文件和库文件地址，其他第三方库的设置与此类似。</div> </center><p>在我们设置好这些环境变量之后，便可以直接在上节项目配置中直接指定库文件名就可以实现对应库文件和头文件的调用</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sr1faiaej30pg0fzk2l.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">MKL的lapack95库文件和对应地址。</div> </center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="http://tva1.sinaimg.cn/large/006fyIojgy1h5sr3jsz7ij30qz097758.jpg">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;">MPI的impi.lib。值得注意的是，这里仍然有Debug版本和Release版本的库文件。</div> </center><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span id="1">[1]. 海量的试错</span></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>setup</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Qsymmetry tutorial</title>
    <link href="/2022/04/20/Qsymmetry-tutorial/"/>
    <url>/2022/04/20/Qsymmetry-tutorial/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="http://tva1.sinaimg.cn/large/006fyIojgy1h5dfvsdb38j31pm0tkah8.jpg" alt=""></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Qsymmetry是基于Python应用群论分析物理系统的对称性求解系统Hamiltonian的计算包，它可以一定程度上简化我们对物理系统对称性的分析过程，但是官方教程缺少直观的图像说明，函数参数信息不详，本文意在详细说明Qsymm函数和对应参数的物理含义，降低其学习的难度。</p><h1 id="群论和对称性"><a href="#群论和对称性" class="headerlink" title="群论和对称性"></a>群论和对称性</h1><p>对称性研究在整个物理学领域占据了重要的位置，描述对称性的数学工具是群论，而物理系统通常涉及的是对称变换，包括系统的平移、旋转以自身在度量空间的对称性，系统所有对称性变换的集合构成对称变换群。</p><h2 id="群的线性表示"><a href="#群的线性表示" class="headerlink" title="群的线性表示"></a>群的线性表示</h2><p>量子态是在希尔伯特空间中描述，对称性变换不改变系统的物理性质，只能是幺正或者反幺正变换，幺正条件保证了线性变换矩阵的正交性，而反幺正变换主要用于描述分立对称性中的时间反演对称性，对应变换是反线性的。</p><h3 id="构成群的条件"><a href="#构成群的条件" class="headerlink" title="构成群的条件"></a>构成群的条件</h3><p>对称性变换满足成群的条件：</p><p>存在唯一幺元</p><script type="math/tex; mode=display">D(E)=\boldsymbol {1}.</script><p>每一群元素对应存在唯一逆元</p><script type="math/tex; mode=display">\quad D(R)D(R)^{-1}=\boldsymbol {1}.</script><p>封闭性</p><script type="math/tex; mode=display"> D(R_1)D(R_2)=D(R_3).</script><p>群乘法满足结合律</p><script type="math/tex; mode=display">[D(R_1)D(R_2)]D(R_3)=D(R_1)[D(R_2)D(R_3)].</script><h4 id="群的正则表示"><a href="#群的正则表示" class="headerlink" title="群的正则表示"></a>群的正则表示</h4><p>群只有乘法，但是可以通过群元作为基矢量张成的群空间构造群代数，定义矢量的加减法、系数乘法以及矢量与矢量间的乘法，并满足对应封闭性，并满足分配律，即可得到群代数。（群代数对于深化群的认识和应用有重要意义，这里只做引入）</p><p>定义群代数的矢量</p><script type="math/tex; mode=display">X=\sum_{R\in G}f(R)R.</script><p>很容易证明有限群任意矢量满足群代数的要求。</p><p>任何有限群都有一个真实线性表示，称为正则表示，利用群代数可以给出有限群的正则表示。因为在群代数中群元素既是矢量也是算符，作为算符满足群的乘积规则。</p><script type="math/tex; mode=display">SR=T=\sum_{P\in G}P D_{PR}(S),\\D_{PR}=\left\{\begin{matrix}1,&P=SR\\0,&P\neq SR\end{matrix}\right..</script><p>一旦给出群的乘法表，便很容易得到群的正则表示$D(G)$。</p><p>以二面体群$D_3$为例，其乘法表</p><script type="math/tex; mode=display">\begin{array}{c|cccccc}\hline D_3& E & D & F & A & B & C \\\hline E & E & D & F & A & B & C \\D & D & F & E & B & C & A \\F & F & E & D & C & A & B \\A & A & C & B & E & F & D \\B & B & A & C & D & E & F \\C & C & B & A & F & D & E \\\hline\end{array}</script><p>可以给出</p><script type="math/tex; mode=display">D(E)=\mathrm{dignal}(1,1,1,1,1,1),\\D(D)=\left(\begin{array}{llllll}0 & 0 & 1 & 0 & 0 & 0 \\1 & 0 & 0 & 0 & 0 & 0 \\0 & 1 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0 & 1 \\0 & 0 & 0 & 1 & 0 & 0 \\0 & 0 & 0 & 0 & 1 & 0\end{array}\right),\\D(A)=\left(\begin{array}{llllll}0 & 0 & 0 & 1 & 0 & 0 \\0 & 0 & 0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 & 1 & 0 \\1 & 0 & 0 & 0 & 0 & 0 \\0 & 0 & 1 & 0 & 0 & 0 \\0 & 1 & 0 & 0 & 0 & 0\end{array}\right),\\\cdots.</script><h3 id="群的一般性质"><a href="#群的一般性质" class="headerlink" title="群的一般性质"></a>群的一般性质</h3><p>群具有以下特征</p><h4 id="子群和重要的集合"><a href="#子群和重要的集合" class="headerlink" title="子群和重要的集合"></a>子群和重要的集合</h4><p><strong>子群：</strong></p><p>群元素的个数即群的阶。只要按照群乘法规则满足成群条件，群G的子集H也可以构成群，即群G的子群。任何群都有幺元和自身这两个平庸的子群。</p><p><strong>陪集：</strong></p><p>由于群乘法的特点，我们可以由群的子群H</p><script type="math/tex; mode=display">H=\{S_1,S_2,S_3,\cdots,S_h\}\quad S_1=E</script><p>分别定义子群的左陪集和右陪集</p><script type="math/tex; mode=display">\begin{matrix}R_jH=\{R_j,R_jS_2,R_jS_3,\cdots,R_jS_h\},\\HR_j=\{R_j,S_2R_j,S_3R_j,\cdots,S_hR_J\}.\end{matrix}\qquad R_j\in G\quad R_j\notin H.</script><p>其中h是子群的阶。之所以定义陪集，一个重要的原因在于可以利用陪集完成对群的划分。</p><script type="math/tex; mode=display">G=H\cup R_2H\cup R_3H\cup\cdots\cup R_dH,\quad g=dh.</script><p>由此可见，群G的阶如果是素数，该群一定不存在非平庸的子群。相反，如果群G的阶可以分解因子$g=mn$，一定可以得到G的子群的阶为$m$或$n$。如果子群H的左陪集等于右陪集，那么该子群就是不变子群或叫正规子群。由不变子群可以定义群G的商群：</p><script type="math/tex; mode=display">Q=G/H.</script><p>可以看出，不变子群H就是商群的幺元，也只有不变子群可以满足群G存在商群的条件。</p><p><strong>共轭类：</strong></p><p>共轭类在物理学中的群论有重要应用，幺正变换沟通了不同表象下的物理量，而对称性变换一般就是幺正变换，而共轭类$\mathcal C_\alpha$描述的就是由群元$S$沟通具有某种共同性质群操作：</p><script type="math/tex; mode=display">R'\longleftrightarrow SRS^{-1}.</script><p>记作：</p><script type="math/tex; mode=display">\mathcal C_\alpha=\{R_1,R_2,\cdots,R_{n(\alpha)}\}=\{R_k|R_k=SR_jS^{-1},\,S\in G\},</script><p>$n(\alpha)$是类元素的个数。</p><p>容易看出，如果取定群元$S$，$R_j$取遍类中所有元素，对应共轭元素不会有重复，而取定类元素$R_j$,$S$取遍群G的元素，类中共轭元素$R_k$一定会重复出现$m$次，使得$n(\alpha)=g/m$。这保证了两个类不会有重复元素。共轭类这个特点从物理图像上相当于描述同一类对称性变换，比如一个空间群中二次轴旋转和四次轴旋转是分属不同的类，通俗地讲，该空间群可以有二次轴类和四次轴类。</p><p>由此我们可以根据共轭类的属性将群G按照类的不同进行划分</p><script type="math/tex; mode=display">G=\{E,\mathcal C^1_{n(\alpha)},\mathcal C^2_{m(\alpha)},\cdots,\mathcal C^l_{n'(\alpha)}\}.</script><p>定义的群元的阶$n$</p><script type="math/tex; mode=display">\underbrace{R\times R\times\cdots\times R}_n=R^n=E</script><p>共轭类的性质决定了同一个共轭类中所有类元素具有相同的阶，因为</p><script type="math/tex; mode=display">[(D(S)D(R)D(S)^{-1}]^n=D(S)D(R)^nD(S)^{-1}=D(E).</script><p>这个特点决定了我们找共轭类只需要在阶数相同的元素中判断。</p><p><strong>群的生成元：</strong></p><p>由群元素阶的定义，可以看出一个完整的循环群$C_n$可以由一个群元素$R$的有限幂次来表达，$R$称为该循环群的生成元，$n$是循环群的阶。这是有限群中去群生成元的定义，往往一个有限群具有一个以上的生成元，比如二面体群$D_3$就有翻转操作和旋转操作两个群生成元，它们的阶数分别是2和3。</p><p>容易混淆的是，对于连续群，比如在物理研究中应用最广泛的李群，定义连续群的生成元为</p><script type="math/tex; mode=display">T_{a} \equiv-\left.i \frac{\partial \mathcal{R}\left(e^{a}, \omega\right)}{\partial \omega}\right|_{\omega=0}.</script><p>对于三维转动群$R( \hat{ \boldsymbol {n}},\omega)=\exp(-i\omega T\cdot \hat{\boldsymbol {n}})$，则三维转动的生成元为</p><script type="math/tex; mode=display">T_{1}=\left(\begin{array}{ccc}0 & 0 & 0 \\0 & 0 & -\mathrm{i} \\0 & \mathrm{i} & 0\end{array}\right),\\T_{2}=\left(\begin{array}{ccc}0 & 0 & \mathrm{i} \\0 & 0 & 0 \\-\mathrm{i} & 0 & 0\end{array}\right),\\T_{3}=\left(\begin{array}{ccc}0 & -\mathrm{i} & 0 \\\mathrm{i} & 0 & 0 \\0 & 0 & 0\end{array}\right).</script><p>同Pauli矩阵非常相似，的确，二维幺正幺模群SU(2)正是三维转动群SO(3)的覆盖群。而连续群的生成元则是微分算符在表示空间的矩阵形式，如此就可以带入量子力学的概念，引入厄密算符和幺正算符的对应。</p><p><strong>自逆类和相逆类</strong></p><p>一个类中的元素$R_j$的逆元也构成对应的类，所谓“逆类”</p><script type="math/tex; mode=display">R_{i}=S R_{j} S^{-1}, \quad R_{i}^{-1}=S R_{j}^{-1} S^{-1}\\\mathcal C_\alpha\rightarrow \mathcal C_\alpha^{-1}</script><p>$\mathcal C_\alpha$和$\mathcal C_\alpha^{-1}$成为相逆类，如果二者重合则称为自逆类。</p><p><strong>从置换群看共轭类：</strong></p><p>置换群可以写成一系列轮换乘积的形式，对应置换的一个轮换结构。</p><p>一个置换可以写作：</p><script type="math/tex; mode=display">R_1=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}=\begin{pmatrix}4&2&1&3\\1&3&2&4\end{pmatrix}=(1,2,3,4),\\R_2=\begin{pmatrix}1&2&3&4\\4&2&1&3\end{pmatrix}=\begin{pmatrix}3&2&4&1\\1&2&3&4\end{pmatrix}=(1,3,4)(2)=(1,3,4).\\</script><p>两个置换乘积：</p><script type="math/tex; mode=display">\begin{aligned}R_1 R_2&=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}\begin{pmatrix}3&2&4&1\\1&2&3&4\end{pmatrix}=\begin{pmatrix}3&2&4&1\\2&3&4&1\end{pmatrix}\\&=\begin{pmatrix}4&2&1&3\\1&3&2&4\end{pmatrix}\begin{pmatrix}1&2&3&4\\4&2&1&3\end{pmatrix}=\begin{pmatrix}1&2&3&4\\1&3&2&4\end{pmatrix}=(2,3)(1)(4)=(2,3)\end{aligned}</script><p>置换群$\mathcal S_3$写成轮换的形式：$\mathcal S_3=\{I,[2\,3],[1\,3],[1\,2],[1\,2\,3],[3\,2\,1]\}$</p><p>置换群$\mathcal S_4$写成轮换的形式：</p><script type="math/tex; mode=display">\mathcal S_4=\{I,[1,2,3,4],[4,3,2,1],\cdots\}</script><p>置换群$\mathcal S_n$的类由$n$的配分数描写，$n$的配分数即不同轮换结构的数目。$n$个序列的一个置换对应一个轮换结构，构成一种配分数：</p><script type="math/tex; mode=display">\sum_i\mathcal l_i=n.</script><p><strong>晶体空间群对称素和共轭类：</strong></p><blockquote><p>空间群的对称素有三种</p><blockquote><ul><li>n次旋转对称轴，其中n=1,2,3,4,6</li><li>对称心，即空间反演对称，记为$i$</li><li>n次旋转反演对称轴，顾名思义，是对体系某旋转对称轴先作用n次旋转操作，然后作用空间反演，整个过程满足对称条件。记为$\overline n$。</li></ul></blockquote></blockquote><p>值得注意的是，这三种对称素构成了一些晶体空间群中非常直观的概念，比如旋转反演$\overline 2$实际上是一个镜像操作，$\overline 6$是一个三次轴加镜像的操作。</p><p>晶体空间群对称素的概念实际上和群的共轭类有直接的联系。这里以$D_{6h}$群直观说明：</p><p><img src="https://pic3.zhimg.com/v2-b150f7aa374dcc0d939969f2dcbf9d62.jpg?source=d16d100b" alt="六棱柱具有空间群$D_{6h}$的对称性"></p><p>对于这样一个棱柱，显然就有一个六次轴，6个不同的二次轴。$D_{6h}$有24个群元，它是$D_6$群作用一个水平反演的结果，用群论的语言即$D_{6h}=D_{6}\otimes V_2$，由两个子群直积而来。而$D_6$群有12个群元，分别包括6阶循环群或6次旋转群$C_6$的六个群元</p><p><img src="https://pic2.zhimg.com/v2-e2e5c4ef444661b7d12b13b883aa6a24_720w.jpg?source=d16d100b" alt=""></p><p>以及二次轴翻转构成的六个群元</p><p><img src="https://pic4.zhimg.com/v2-a03342a32969510aea4f132e67528fcc_720w.jpg?source=d16d100b" alt=""></p><p>共同组成。其中六次转动把两次转动联系起来，幺元构成一类，六次轴构成一类，两个二次轴各自构成一类，所以$D_{6h}$具有四个类，四个类都是自逆类。这里面判断可以由乘法表给出，因为</p><script type="math/tex; mode=display">(ST)=S(TS)S^{-1}.</script><p>所以我们只需关注乘法表对角线的元素。</p><p><img src="https://pic2.zhimg.com/v2-b60219f022441721c2d5e4cdd6949ff9_720w.jpg?source=d16d100b" alt=""></p><h4 id="同构和同态"><a href="#同构和同态" class="headerlink" title="同构和同态"></a>同构和同态</h4><p>这两个概念联系了群论中一个应用很广泛的概念：映射。定义映射$\psi:G\rightarrow H$。首先$\psi$是保群映射，满足</p><script type="math/tex; mode=display">\psi(D(R))\psi(D(R'))=\psi(D(R)D(R'))\\\psi(D(R)^{-1})=\psi(D(R))^{-1},\quad\psi(D(E))=h_e</script><p>根据这个条件可以给出对原群的逆元和幺元的一一映射，保证了群的生成。因此如果映射是单射且满射，则在该映射下原群和新群同构，如果仅仅只是单射，则两群同态。</p><h3 id="幺正表示和特征标表"><a href="#幺正表示和特征标表" class="headerlink" title="幺正表示和特征标表"></a>幺正表示和特征标表</h3><p>有限群的线性表示是以舒尔定理为保证的，这里只贴出重要的结论不多做介绍和证明，详见各种群论教材。</p><p>对称群幺正表示的约化</p><script type="math/tex; mode=display">G(R) \Rightarrow D(R) \Rightarrow X^{-1} D(R) X=\oplus_{i} a_{i} D^{i}(R)</script><center><img src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5igoobjj307c05xjs1.jpg"></center><p>有限群不等价不可约幺正表示的正交性：</p><script type="math/tex; mode=display">\sum_{R \in G} D_{\mu \rho}^{i}(R)^{*} D_{\nu \lambda}^{j}(R)=\frac{g}{m_{j}} \delta_{i j} \delta_{\mu \nu} \delta_{\rho \lambda}</script><p>随即可以得到特征标正交：</p><script type="math/tex; mode=display">\sum_{R \in G} \chi^{i}(R)^{*} \chi^{j}(R)=g \delta_{i j} .</script><p>一个重要的推论：</p><script type="math/tex; mode=display">\sum_{R\in G}|\chi(R)|^2=g.</script><p>它是有限群不可约表示的充要条件。<br>但是从物理的角度出发，一个可测的物理系统涉及的对称变换包括各种表象变换毫无疑问都是幺正变换，这是量子力学基础的内容。所以群的线性表示论的核心就是以线性空间来描述群空间，寻找群的不等价不可约表示。这样的概念可以直接过渡到复数域，利用共轭类的特性给出有限群的特征标。比如二面体群有三个类，三个类都是自逆类，所以特征标都是实数。</p><script type="math/tex; mode=display">\begin{array}{c|ccc}\hline D_{3} & E & 2 C_{3} & 3 C_{2}^{\prime} \\\hline A & 1 & 1 & 1 \\B & 1 & 1 & -1 \\E & 2 & -1 & 0 \\\hline\end{array}</script><script type="math/tex; mode=display">\begin{array}{c|cccccc}\hline C_6 & E & R & R^{2} & R^{3} & R^{4} & R^{5} \\\hline A & 1 & 1 & 1 & 1 & 1 & 1 \\B & 1 & -1 & 1 & -1 & 1 & -1 \\E_{1} & 1 & -\omega^{*} & \omega & -1 & \omega^{*} & -\omega \\E_{1}^{\prime} & 1 & -\omega & \omega^{*} & -1 & \omega & -\omega^{*} \\E_{2} & 1 & \omega & \omega^{*} & 1 & \omega & \omega^{*} \\E_{2}^{\prime} & 1 & \omega^{*} & \omega & 1 & \omega^{*} & \omega \\\hline \end{array}\\ \omega=\exp \{-\mathrm{i} 2 \pi / 3\}</script><script type="math/tex; mode=display">\begin{array}{c|cccccc}\hline \mathrm{D}_{6} & E & 2 C_{6} & 2 C_{6}^{2} & C_{6}^{3} & 3 C_{2}^{\prime} & 3 C_{2}^{\prime \prime} \\\hline A_{1} & 1 & 1 & 1 & 1 & 1 & 1 \\A_{2} & 1 & 1 & 1 & 1 & -1 & -1 \\B_{1} & 1 & -1 & 1 & -1 & 1 & -1 \\B_{2} & 1 & -1 & 1 & -1 & -1 & 1 \\E_{1} & 2 & 1 & -1 & -2 & 0 & 0 \\E_{2} & 2 & -1 & -1 & 2 & 0 & 0 \\\hline\end{array}</script><h2 id="SO-3-和SU-2"><a href="#SO-3-和SU-2" class="headerlink" title="SO(3)和SU(2)"></a>SO(3)和SU(2)</h2><p>SO(3)即三维特殊正交群，三维旋转群是SO(3)。旋转操作的算符形式为</p><script type="math/tex; mode=display">e^{-i\frac{\boldsymbol {J}\cdot\boldsymbol {n}\phi}{\hbar}}.</script><p>所以三维旋转变换总是可以写成正交矩阵的形式。樱井在《Modern Quantum Mechanics》角动量一章详细介绍三维转动系统和二分量旋子系统。他利用无穷小转动的技术结合前一章平移变换的讨论阐述了转动算符的由来。</p><p>首先，这里面的$\boldsymbol {J}$是旋转操作的生成元，因为旋转算符在无穷小转动下是$1-iJ\Delta \phi/\hbar$。</p><p>根据欧拉转动</p><script type="math/tex; mode=display">\mathcal{D}(\alpha, \beta, \gamma)=\mathcal{D}_{z}(\alpha) \mathcal{D}_{y}(\beta) \mathcal{D}_{z}(\gamma).</script><p>我们可以引入一个特殊的转动或者正交变换$S(\psi,\theta)$</p><script type="math/tex; mode=display">S(\varphi, \theta)=R\left(\vec{e}_{3}, \varphi\right) R\left(\vec{e}_{2}, \theta\right)=\left(\begin{array}{ccc}\cos \varphi \cos \theta & -\sin \varphi & \cos \varphi \sin \theta \\\sin \varphi \cos \theta & \cos \varphi & \sin \varphi \sin \theta \\-\sin \theta & 0 & \cos \theta\end{array}\right).</script><p>显而易见，这个操作是可以把$z$轴上的点转到$\hat{\boldsymbol {n}}(\psi,\theta)$方向，$\theta$和$\psi$确定了球坐标的极角和方位角。所以</p><script type="math/tex; mode=display">ST_3S^{-1}=\hat{\boldsymbol {n}}T.</script><p>进而可以给出一个重要关系</p><script type="math/tex; mode=display">\begin{aligned}R(\hat{\boldsymbol symbol{n}}, \omega) &=S(\varphi, \theta) R\left(\vec{e}_{3}, \omega\right) S(\varphi, \theta)^{-1}=\exp \left\{-\mathrm{i} \omega S T_{3} S^{-1}\right\} \\&=\exp \{-\mathrm{i} \omega \hat{\boldsymbol symbol{n}} \cdot \vec{T}\}=\exp \left\{-\mathrm{i} \sum_{a=1}^{3} \omega_{a} T_{a}\right\}\end{aligned}.</script><p>可见任何可能的转动$R(\hat{\boldsymbol symbol{n}}, \omega)$都与相应的$R\left(\vec{e}_{3}, \omega\right) $共轭, 或者说同类，他们之间差一个正交变换。关系式直接给出了维格纳公式。于是我们可以看出</p><script type="math/tex; mode=display">R(\hat{\boldsymbol symbol{n}}, \omega)=R(-\hat{\boldsymbol symbol{n}}, 2 \pi-\omega), \quad R(\hat{\boldsymbol symbol{n}}, \pi)=R(-\hat{\boldsymbol symbol{n}}, \pi).</script><p>所以三维转动是在半径为$\pi$的球内连续变化，在球面上直径两端的点代表同一转动。</p><p>类似地，可以给出二维幺正幺模群SU(2):</p><script type="math/tex; mode=display">\exp \left(\frac{-i \sigma \cdot \hat{\mathbf{n}} \phi}{2}\right)=\left|\begin{array}{ll}\cos \left(\frac{\phi}{2}\right)-i n_{z} \sin \left(\frac{\phi}{2}\right) & \left(-i n_{x}-n_{y}\right) \sin \left(\frac{\phi}{2}\right) \\\left(-i n_{x}+n_{y}\right) \sin \left(\frac{\phi}{2}\right) & \cos \left(\frac{\phi}{2}\right)+i n_{z} \sin \left(\frac{\phi}{2}\right)\end{array}\right|.</script><p>注意到幺正幺模的条件，对SU(n)</p><script type="math/tex; mode=display">SU(n):\{U|U\in \mathrm GL(n,\mathbb C),U^\dagger U=\boldsymbol {I},|U|=1\}.</script><p>具体到SU(2)</p><script type="math/tex; mode=display">SU(2):\left\{\left[\begin{array}{cc}a & b \\-b^{*} & a^{*}\end{array}\right]|a, b \in \mathbb{C},| a|^{2}+|b|^{2}=1\right\}.</script><p><center><img src=https://pic1.zhimg.com/80/v2-8e319add5e93e8af633274100a5577a8_720w.jpg><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    SU(2)和SO(3)（图源:见水印）    </div></center></p><h1 id="Qsymm主要的模块"><a href="#Qsymm主要的模块" class="headerlink" title="Qsymm主要的模块"></a>Qsymm主要的模块</h1><p>Qysmm是一个python程序包，其中包含了一系列对称性模块和算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> qsymm<br></code></pre></td></tr></table></figure><h2 id="给出模型的对称性分类"><a href="#给出模型的对称性分类" class="headerlink" title="给出模型的对称性分类"></a>给出模型的对称性分类</h2><p>我们可以利用Qsymm中的对称性分类模块寻找已有模型的所有对称性。当然</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">H = qsymm.Model(ham)<span class="hljs-comment">#利用model模块可以给出对应矩阵的展开形式</span><br>cubic_group = qsymm.groups.cubic()<span class="hljs-comment">#Qsymm预置的群类，这里是立方体O群</span><br>discrete_symm, continuous_symm = qsymm.symmetries(H, cubic_group)<span class="hljs-comment">#利用symmetries模块，依据主要参数可以给出系统所有存在的对称性，包括离散对称性和连续对称性。这里cubic_group的arg是候选晶体点群，迭代算法找到系统与之匹配的对称性。</span><br>print(<span class="hljs-built_in">len</span>(discrete_symm), <span class="hljs-built_in">len</span>(continuous_symm))<br>qsymm.PointGroupElement(R=np.diag([<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]), U=<span class="hljs-string">&#x27;kron(sigma_y, sigma_z)&#x27;</span>)<span class="hljs-comment">#利用点群模块PointGroupElement可以直观显示对应幺正表示的对称性操作。示例给出的是二维系统关于x轴的镜像。</span><br></code></pre></td></tr></table></figure><h2 id="导出连续性模型"><a href="#导出连续性模型" class="headerlink" title="导出连续性模型"></a>导出连续性模型</h2><p>利用对称性变换关系</p><script type="math/tex; mode=display">\begin{aligned}P_{R} \psi_{\alpha}(\boldsymbol k) &=\sum_{\beta} \psi_{\beta}(\boldsymbol k) D_{\beta \alpha}(R) \\H(\boldsymbol k) &=P_{R} H(\boldsymbol k) P_{R}^{-1}\end{aligned}</script><p>可以通过已知对称性操作导出连续性模型的Hamiltonian，所以预先需要确定所要研究的系统全部对称性。</p><p>利用Qsymm对称操作模块，这里简要给出一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">TR = qsymm.time_reversal(实空间维度， 幺正矩阵U，spin（整数或半整数或给出三个对应角动量矩阵）) <span class="hljs-comment">#这里是离散对称性中的时间反演对称性。可选择地利用对称性操作的幺正表示或者系统的自旋角动量确定该对称性，下同</span><br>Mx = qsymm.mirror(镜像轴[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]，幺正表示U，spin （整数或半整数或给出三个对应角动量矩阵）) <span class="hljs-comment">#这是镜像对称性</span><br>IN = qsymm.inversion(实空间维度,幺正矩阵U) <span class="hljs-comment">#这是空间反演对称性</span><br>C = qsymm.chiral(实空间维度,幺正表示U) <span class="hljs-comment">#这是手征对称性</span><br>Cn = qsymm.rotation(<span class="hljs-number">1</span>/n, 旋转轴，反演操作(默认false, 幺正矩阵U), 角动量)<span class="hljs-comment">#这是点群中最为基础的旋转对称性。这里n=&#123;1,2,3,4,6&#125;为晶轴旋转，U的维度决定不可约表示的维度</span><br><br></code></pre></td></tr></table></figure><p>利用这些已有的对称性，通过对称变换约束性关系，可以利用continuum_hamiltonian模块直接给出我们需要的连续性模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dim = <span class="hljs-number">2</span>           <span class="hljs-comment">#模型维度</span><br>total_power = <span class="hljs-number">3</span>      <span class="hljs-comment">#动量的阶数</span><br>family = qsymm.continuum_hamiltonian(symmetries, dim,total_power, prettify=<span class="hljs-literal">True</span>) <span class="hljs-comment">#这里symmetries即我们预先确定的系统的对称性，dim是系统的维度，total_power是动量的阶数。</span><br><br></code></pre></td></tr></table></figure><h2 id="导出紧束缚模型"><a href="#导出紧束缚模型" class="headerlink" title="导出紧束缚模型"></a>导出紧束缚模型</h2><p>紧束缚模型的导出和连续性模型类似，需要预先确定体系的对称性，给出对称性的过程和连续性模型的一致。</p><p>唯一不同的是利用Qsymm的Bloch_family模块导出紧束缚模型还需要确定最近邻原子轨道间的hopping，通常需要给体系不同原子做标记，并给出对应原子的轨道数，然后利用hopping vector最终确定最近邻hopping的紧束缚模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">norbs = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>)] <span class="hljs-comment">#标记为a的原子有三个轨道，体系只有一种原子。</span><br>norbs = [(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">1</span>)] <span class="hljs-comment">#标记为A和B的原子各自有一个轨道，体系有两种原子。</span><br>hopping_vectors = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])] <span class="hljs-comment">#定义a原子和a原子的最近邻hopping，hopping矢量是默认的[1,0]</span><br>hopping_vectors = [(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])]<span class="hljs-comment">#定义A原子和B原子的最近邻hopping，hopping矢量是[0,1],表示从B的轨道hopping到A的轨道。</span><br>family = qsymm.bloch_family(hopping_vectors, symmetries, norbs)<span class="hljs-comment">#bloch_family模块三个主要参数即可确定体系的紧束缚模型，分别是hopping矢量，对称性集合，以及对于原子标记及轨道数。</span><br>qsymm.display_family(family<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>symbol calculation</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MPI essential</title>
    <link href="/2022/04/20/MPI-essential/"/>
    <url>/2022/04/20/MPI-essential/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>MPI</strong>，即“<strong>Message Passing Interface</strong>”，<strong>信息传递接口</strong>，作为高性能计算绕不开的跨平台通讯协议，广泛地应用在科学计算的项目中。本文旨在以实践为目的介绍通过MPI实现并行计算的基本方式以及MPI应用于并行计算的核心思路。<br>主要参考MPItutorial<a href="#1"><sup>[1]</sup></a>和mpi4py<a href="#2"><sup>[2]</sup></a> 的内容，实例以python为主要介绍，代码来自于mpi4py。</p><h1 id="开始并行计算"><a href="#开始并行计算" class="headerlink" title="开始并行计算"></a>开始并行计算</h1><p>&emsp;&emsp;一般运行并行程序或者脚本，在linux和windows平台分别有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mpirun -n [yourprocessNumber] ./xxx<br>mpiexec -n [yourprocessNumber] ./xxx<br></code></pre></td></tr></table></figure><br>这里进程数是编程人员人为规定的，它依据计算程序并行任务实际需求而定。</p><h1 id="一些容易混淆的概念"><a href="#一些容易混淆的概念" class="headerlink" title="一些容易混淆的概念"></a>一些容易混淆的概念</h1><p>&emsp;&emsp;在处理并行计算的过程中，初学者容易对并行计算的一些概念产生误解，这里做简要解释。</p><h2 id="进程（process）和线程（thread）"><a href="#进程（process）和线程（thread）" class="headerlink" title="进程（process）和线程（thread） "></a>进程（process）和线程（thread）<span id="p"> </span></h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="https://cdn.jsdelivr.net/gh/sophisli/picdomain/img/Multithreaded_process.svg"; width="40%">    <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;width:400px;"> 进程和多线程关系示意图。一个进程可以在时间轴上划分出多个线程，线程之间的时间区间不重叠。图源WiKi</div> </center><p>&emsp;&emsp;我们日常使用计算机最常遇到就是任务进程的概念，容易理解的是，计算机处理数据的过程也和人类似，需要将具体任务拆分为若干子集合，然后分别完成。这里一个任务对应一个进程，而子集合的处理则对应计算机处理线程的划分。由于，CPU物理架构的限制，一个物理核心所集成的多级缓存只能同时容纳一个线程的任务数据，故而CPU一个物理核心只能同时处理一个任务进程，这里同时的概念就涉及了并行和并发的区分。</p><h2 id="并行（parallel）和并发（concurrent）"><a href="#并行（parallel）和并发（concurrent）" class="headerlink" title="并行（parallel）和并发（concurrent）"></a>并行（parallel）和并发（concurrent）</h2><center> <img src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5i60267j30nx0ffjv5.jpg" width="80%" >  <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px;"><br>并行与并发</div></center><p>&emsp;&emsp;并行概念的核心是同时（synchronization），而多个物理核心的CPU如图右所示同时处理对应多个进程实现的是并行，否则为并发。一个容易引起误解的概念是超线程（multithreads）。</p><p>&emsp;&emsp;Intel的CPU因为具有超线程技术，即存在所谓虚拟的核心，实际上超线程技术是一种多线程处理的优化策略，不能认为一个4核8线程的处理器可以并行处理8个进程，按照之前的理解，它只能4核并行。事实上，计算机在处理任务进程时可以通过协调各进程的线程树实现高效的数据处理，实现1+1&gt;2的处理效率，这是线程优化的结果。</p><center><img src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5iba01lj31ja0e17am.jpg"> <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 4px;font-size:13px;">一个CPU物理的核只能在一个时间段处理一个线程。CPU物理核心数决定了计算机并行处理的能力，即物理核数等于可并行处理的进程数。</div></center><h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><h2 id="三种语言版本的比较"><a href="#三种语言版本的比较" class="headerlink" title="三种语言版本的比较"></a>三种语言版本的比较</h2><h3 id="C-C"><a href="#C-C" class="headerlink" title="C\C++ "></a>C\C++<span id="c"> </span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">inxlude &lt;studio.h&gt;<br>include &lt;mpi.h&gt;<br>MPI_Init( <span class="hljs-keyword">int</span>* argc, <span class="hljs-keyword">char</span>*** argv)<span class="hljs-comment">//初始化MPI环境</span><br>MPI_Comm_size( MPI_Comm communicator, <span class="hljs-keyword">int</span>* size) <span class="hljs-comment">//获得通信域总的进程数,也就是通信域（communicator）的大小，它实际上就是一开始mpirun -n命令中的人为设定的进程数。通信域类似一个容器，包含了相应进程的信息，下同。</span><br>MPI_Comm_rank( MPI_Comm communicator, <span class="hljs-keyword">int</span>* rank) <span class="hljs-comment">//给每个进程进行编号，相当于对应进程的ID</span><br>MPI_Finalize() <span class="hljs-comment">//终止MPI环境</span><br></code></pre></td></tr></table></figure><h3 id="Fortran"><a href="#Fortran" class="headerlink" title="Fortran"></a>Fortran</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mpi.h&quot;</span><br>MPI_Init( <span class="hljs-built_in">int</span>*ierr)<span class="hljs-comment">!初始化MPI环境，获得一个整数型的返回值ierr</span><br>MPI_Comm_size( MPI_Comm communicator, <span class="hljs-built_in">int</span>* <span class="hljs-built_in">size</span>, <span class="hljs-built_in">int</span>* ierr) <span class="hljs-comment">!获得mpirun的进程数，和C\C++不同的是，Fortran关于MPI的子例程函数需要ierr这个参数（下同）</span><br>MPI_Comm_rank( MPI_Comm communicator, <span class="hljs-built_in">int</span>* rank , <span class="hljs-built_in">int</span>* ierr) <span class="hljs-comment">!给进程编号</span><br>MPI_Finalize(<span class="hljs-built_in">int</span>*ierr) <span class="hljs-comment">!终止MPI环境</span><br></code></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<span class="hljs-comment">#从MPI4py导出MPI</span><br>comm = MPI.COMM_WORLD<span class="hljs-comment">#获得通信域参数，等同于C或Fortran中的“MPI_Comm_World”。</span><br>rank = comm.Get_rank()<span class="hljs-comment">#给通信域中的进程编号</span><br>size = comm.Get_size()<span class="hljs-comment">#获取通信域总的进程数</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;C和Fortran作为编译型语言，在实现MPI的语法上具有类似的形式，其中MPI_Init和MPI_Finalize分别是初始化通信接口的环境和结束环境，并且函数的调用并没有返回值。而Python作为脚本型语言，是以函数返回值的形式获取MPI的参数，并不需要初始化(MPI_Init)\终止(MPI_Finalize) MPI环境的函数，形式上更简洁一些，但基础部件大同小异，MPI在Python上的组件和属性详细内容可以参看<a href="https://mpi4py.readthedocs.io/en/stable/mpi4py.MPI.html">mpi4py.MPI</a>。另外，在C和Fortran中需要额外调用mpi.h这个标准库文件。</p><h1 id="进程间点对点通信（point-to-point-communication）"><a href="#进程间点对点通信（point-to-point-communication）" class="headerlink" title="进程间点对点通信（point-to-point communication）"></a>进程间点对点通信（point-to-point communication）</h1><h2 id="MPI-Recv-amp-MPI-Send"><a href="#MPI-Recv-amp-MPI-Send" class="headerlink" title="MPI_Recv&amp;MPI_Send"></a>MPI_Recv&amp;MPI_Send</h2><p>&emsp;&emsp;根据<a href="#p">上节</a>对进程的描述，进程可以类比现实生活中的邮箱，邮箱的功能就是信件的收发，而通俗地讲，进程就是包含一系列计算机待处理任务的一个集合。所以MPI点对点通信实现的就是两个进程间的信息收发，也就是所谓通信(下图所示)。点对点通信是MPI的基础功能。</p><center> <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);" src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5i8h7u7j31100ba0uf.jpg" > <br>   <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">进程间点对点通信</div></center><p>&emsp;&emsp;以C为例，MPI点对点通信两个重要的组件是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Recv( <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> source, <br> <span class="hljs-keyword">int</span> tag, MPI_Comm communicator, MPI_Status* status)<span class="hljs-comment">//接收组件 </span><br>MPI_Send( <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> destination, <br> <span class="hljs-keyword">int</span> tag, MPI_Comm communicator) <span class="hljs-comment">//发送组件</span><br></code></pre></td></tr></table></figure><p>即收发组件。</p><p>&emsp;&emsp;这里MPI_Recv组件的参数“<strong>data</strong>”即进程需要收发的数据，“<strong>count</strong>”则是对应“<strong>data</strong>”的数量，“<strong>datatype</strong>”是收发数据的数据类型(见<a href="#table1">下表</a>）。“<strong>source</strong>”是一个整型数据，即对于接收信息的进程而言，它就是指发送该信息进程的ID，和MPI_Send的“<strong>destination</strong>”相对。“<strong>communicator</strong>”即通信域或通讯器，一般在C或者Fortran中有关键字“MPI_Comm_World”，如<a href="#c">上文</a>提到的，它包含了初始化MPI环境中所有的进程，与之对应，就有“MPI_Comm_Self”，即只包含各个进程自己的进程组。而“<strong>tag</strong>”是用于标识该数据的标签。</p><p>&emsp;&emsp;很容易看出收发组件的参数稍有差异，MPI_Recv多了一项“status”，而且还是MPI派生的数据类型。字面意思不难理解，好比我们在现实生活中收到邮件先签名确认接收无误，这个聚合类型的“status”主要包含了所接收信息的标识（发送该信息进程的ID，该信息的标签以及长度），以确保两进程间准确的信息收发。</p> <table  width="100%" border="0"><span id="table1"></span>     <h1 align="center" style="font-size:15pt">         MPI Datatype     </h1>  <tr>    <th>MPI Datatype</th>    <th>C/C++</th>      <th>Fortran</th>  </tr>  <tr>    <td>MPI_SHORT</td>    <td>short int</td>      <td>Integer(Selected_Int_Kind(4))</td>  </tr>    <tr>        <td>MPI_INT</td>        <td>int</td>        <td>Integer(Selected_Int_Kind(9)</td>    </tr>  <tr>    <td>MPI_LONG</td>    <td>Long int</td>      <td>Integer(Selected_Int_Kind(9)</td>  </tr>  <tr>   <td>MPI_LONG_LONG</td>      <td>long long int</td>      <td>Integer(Selected_Int_Kind(15))</td>  </tr>    <tr>        <td>MPI_FLOAT</td>        <td>float</td>        <td>Real(Selected_Int_Kind(9))</td>    </tr>    <tr>        <td>MPI_DOUBLE</td>        <td>double</td>        <td>Real(Selected_Ind_Kind(15)</td>    </tr></table>  <p>实际上，我们可以用另外两个组件获得”status”信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">MPI_Get_count( MPI_Status* status, MPI_Datatype datatype, <span class="hljs-keyword">int</span>* count) <br>MPI_Probe( <span class="hljs-keyword">int</span> source, <span class="hljs-keyword">int</span> tag, MPI_Comm comm, MPI_Status* status) <br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>&emsp;&emsp;以下是实现进程1和0之间的通信：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<span class="hljs-comment">#导入MPI组件</span><br><br>comm = MPI.COMM_WORLD<span class="hljs-comment">#初始化通信域</span><br>rank = comm.Get_rank()<span class="hljs-comment">#获得当前进程ID</span><br><br><span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>:<br>    data = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">3.14</span>&#125;<span class="hljs-comment">#初始化一个dist</span><br>    comm.send(data, dest=<span class="hljs-number">1</span>, tag=<span class="hljs-number">11</span>)<span class="hljs-comment">#用ID为0的根进程发送tag为11的数据data到ID为1的进程</span><br><span class="hljs-keyword">elif</span> rank == <span class="hljs-number">1</span>:<br>    data = comm.recv(source=<span class="hljs-number">0</span>, tag=<span class="hljs-number">11</span>)<span class="hljs-comment">#ID为1的进程接受来根进程的数据</span><br></code></pre></td></tr></table></figure><p>Python实现MPI是借助mpi4py这个宏包，作为脚本型语言，省去了在C和Fortran中的一些参数，形式上更为简洁，将作为以下主要的实例演示。</p><h1 id="组通信（collective-communication）"><a href="#组通信（collective-communication）" class="headerlink" title="组通信（collective communication）"></a>组通信（collective communication）</h1><p>组通信是实现一个communicator中所有进程间通信的概念。</p><h2 id="对齐各进程时间点和一多广播：Barrier-amp-Bcast"><a href="#对齐各进程时间点和一多广播：Barrier-amp-Bcast" class="headerlink" title="对齐各进程时间点和一多广播：Barrier&amp;Bcast"></a>对齐各进程时间点和一多广播：Barrier&amp;Bcast</h2><p>&emsp;&emsp;组通信实现的前提是各进程时间点的对齐，实现同步(即synchronization, syn-这个词缀有共同的意思，chon=time，chronic就是慢性的长期的意思)，MPI_Barrier这个组件可以实现全部进程同步，语法是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Barrier(MPI_Comm communicator) <br></code></pre></td></tr></table></figure><p>实现的过程在MPI<a href="https://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication">教程</a>里有详细描述，原理顾名思义就是在固定一个时间点，在该时间点设置一个阻碍，并作用于通信域中每一个进程。下面组通信的所有组件都是默认所有进程是时间同步的，也就是组件本身具有实现Barrier的功能。</p><p>&emsp;&emsp;实现进程同步之后，我们便可以通过并行的思路实现数据的群发，也就是所谓的广播（broadcast），这就涉及MPI_Bcast这个组件的功能。</p><p>C的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Bcast( <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> root, MPI_Comm communicator) <br></code></pre></td></tr></table></figure><p>主要的参数与上面的点对点通信组件类似，这里不多解释。</p><p>python实现的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<br><br>comm = MPI.COMM_WORLD<br>rank = comm.Get_rank()<br><br><span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>:<br>    data = &#123;<span class="hljs-string">&#x27;key1&#x27;</span> : [<span class="hljs-number">7</span>, <span class="hljs-number">2.72</span>, <span class="hljs-number">2</span>+<span class="hljs-number">3j</span>],<span class="hljs-comment">#在0进程建立一个data的字典</span><br>            <span class="hljs-string">&#x27;key2&#x27;</span> : ( <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>)&#125;<br><span class="hljs-keyword">else</span>:<br>    data = <span class="hljs-literal">None</span><br>data = comm.bcast(data, root=<span class="hljs-number">0</span>)<span class="hljs-comment">#comm.bcast实现的就是将data中的数据从0进程群发到comm所有的进程中</span><br></code></pre></td></tr></table></figure><h2 id="散发（Scatter）和收集（Gather）"><a href="#散发（Scatter）和收集（Gather）" class="headerlink" title="散发（Scatter）和收集（Gather）"></a>散发（Scatter）和收集（Gather）</h2><p>&emsp;&emsp;MPI散发和收集信息的组件基本上可以满足很大一部分科学计算并行处理的要求，二者实现了全部进程间不同数据的接收和发送。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/broadcastvsscatter.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    Bcast和scatter的区别（图源：mpitutorial.com）    </div></center><p>上图可以看出，Bcast和Scatter实现信息发送的形式是一致的，只不过前者实现的同一数据的分发，相当于把根进程的一个数据copy给所有进程，而后者实现了把不同数据分别派发给对应进程的功能，这在实际应用中非常有意义。实际上，在科学计算中就是需要把一个大型任务拆解为很多细小的部分，分而治之，这符合并行编程的基本思路。故而，MPI散发和收集组件有重要的应用场景。</p><p>&emsp;&emsp;Scatter的作用是一个具体的进程向全部进程派发不同的数据，那么Gather就是从全部进程中收集它们各自不同的数据，是Scatter的逆过程，如下图。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/gather.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    MPI_Gather的实现过程（图源：mpitutorial.com）    </div></center><p>这两个组件的基本接口：<span id="gather"> </span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Scatter( <span class="hljs-keyword">void</span>* send_data, <span class="hljs-keyword">int</span> send_count, MPI_Datatype send_datatype, <span class="hljs-keyword">void</span>* recv_data,<span class="hljs-keyword">int</span> recv_count, MPI_Datatype recv_datatype, <span class="hljs-keyword">int</span> root, MPI_Comm communicator);<br>MPI_Gather( <span class="hljs-keyword">void</span>* send_data, <span class="hljs-keyword">int</span> send_count, MPI_Datatype send_datatype, <span class="hljs-keyword">void</span>* recv_data,<span class="hljs-keyword">int</span> recv_count, MPI_Datatype recv_datatype, <span class="hljs-keyword">int</span> root, MPI_Comm communicator) <br></code></pre></td></tr></table></figure><p>相较于Bcast，函数参数明显增加。因为涉及向不同进程分发不同数据或者从不同进程接收不同数据的过程，所以这里需要逐个定义分发和接收数据的数据类型（send_datatype&amp;recv_daratype）以及数量(send_count&amp;recv_count)。而指定根进程（root）以及通信域（communicator）则与之前的组件相同。</p><p>&emsp;&emsp;另外，Gather还有一个升级版本Allgather：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/allgather.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    MPI_Allgather的实现过程（图源：mpitutorial.com）    </div></center><p>相当于所有进程都执行了Gather的操作，收集其他进程上不同的数据，实现的效果相当于把原先Gather在根进程收集的数据copy到了所有进程中。它的输入参数除了不用指定根进程，其他与Gather是相同的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Allgather( <span class="hljs-keyword">void</span>* send_data, <span class="hljs-keyword">int</span> send_count, MPI_Datatype send_datatype, <br> <span class="hljs-keyword">void</span>* recv_data, <span class="hljs-keyword">int</span> recv_count, MPI_Datatype recv_datatype, MPI_Comm communicator) <br></code></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>MPI_Scatter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<br><br>comm = MPI.COMM_WORLD<br>size = comm.Get_size()<br>rank = comm.Get_rank()<br><br><span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>:<br>    data = [(i+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<span class="hljs-comment">#在0进程中创建一个data的一维数组，它的大小是通信域的大小（comm.Get_size），这里用了python的隐式输入。</span><br><span class="hljs-keyword">else</span>:<br>    data = <span class="hljs-literal">None</span><br>data = comm.scatter(data, root=<span class="hljs-number">0</span>)<span class="hljs-comment">#以0进程作为根进程分发数组data中的数据给所有进程</span><br><span class="hljs-keyword">assert</span> data == (rank+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span><span class="hljs-comment">#这里插了一个断点，以判断Scatter是否实现了数组数据按照进程ID有序分发。</span><br></code></pre></td></tr></table></figure><p>MPI_Gather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<br><br>comm = MPI.COMM_WORLD<br>size = comm.Get_size()<br>rank = comm.Get_rank()<br><br>data = (rank+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span><span class="hljs-comment">#这里在各个进程中创建了一个data的数据，它是以进程ID+1的平方实现的。</span><br>data = comm.gather(data, root=<span class="hljs-number">0</span>)<span class="hljs-comment">#调用Gather组件，指定根进程为0，实现从所有进程收集data的数据</span><br><span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>        <span class="hljs-keyword">assert</span> data[i] == (i+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span><span class="hljs-comment">#插入断点，判断Gather的功能是否实现</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">assert</span> data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>MPI_Allgather:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<br><span class="hljs-keyword">import</span> numpy<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matvec</span>(<span class="hljs-params">comm, A, x</span>):</span><span class="hljs-comment">#定义一个matvec的函数，实现对方阵A和矢量x的乘法（vecter product）的并行处理</span><br>    m = A.shape[<span class="hljs-number">0</span>] <span class="hljs-comment"># 讲A矩阵的行数赋值给m</span><br>    p = comm.Get_size()<span class="hljs-comment">#获得通信域的进程数</span><br>    xg = numpy.zeros(m*p, dtype=<span class="hljs-string">&#x27;d&#x27;</span>)<span class="hljs-comment">#利用numpy的零矩阵函数建立一个m*p的零矩阵，数据类型选择双精度浮点型。</span><br>    comm.Allgather([x,  MPI.DOUBLE],<br>                   [xg, MPI.DOUBLE])<span class="hljs-comment">#使用Allgather将各个进程中的矢量x收集到矩阵xg中。</span><br>    y = numpy.dot(A, xg)<span class="hljs-comment">#A和收集完x的矩阵xg做矢量乘积，每个进程中都存储了这个乘积y的结果。</span><br>    <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>注意，Scatter和Gather在mpi4py中的参数相较于C省略了很多，不过基本的实现方式都是相同的。而且从gather的实现过程中可以看出，python中无需定义额外定义根进程的一维数组“data”，这是脚本语言相当方便的地方。</p><h2 id="规约（Reduce）"><a href="#规约（Reduce）" class="headerlink" title="规约（Reduce）"></a>规约（Reduce）</h2><p>&emsp;&emsp;规约的功能实际上是Gather的结合再升级，升级的内容就是对从不同进程中收集的数据施加一个额外的操作（MPI_Op, Op是operation的缩写）。实现的过程如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"  src="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/mpi_reduce_2.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    MPI_Gather的实现过程（图源：mpitutorial.com）    </div></center><p>规约的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Reduce( <span class="hljs-keyword">void</span>* send_data, <span class="hljs-keyword">void</span>* recv_data, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class="hljs-keyword">int</span> root, MPI_Comm communicator) <br></code></pre></td></tr></table></figure><p>它仅比<a href="#gather">Gather</a>多了一个参数MPI_Op，这里给出MPI_Op常用的几种操作，如下表：</p><div style="float:center"> <table name="table2">    <center><h1 style="font-size:20px">MPI operation</h1></center>  <tr>    <th>name</th>    <th>function</th>  </tr>  <tr>    <td>MPI_MAX</td>    <td> 返回最大值</td>  </tr>    <tr>        <td>MPI_MIN</td>        <td>返回最小值</td>    </tr>  <tr>    <td>MPI_SUM </td>    <td>对所有元素求和</td>  </tr>  <tr>   <td>MPI_PROD</td>      <td>所有元素相乘</td>  </tr>    <tr>        <td>MPI_LAND</td>        <td>跨元素执行逻辑“and”（LAND是logical and的缩写）</td>    </tr>    <tr>        <td>MPI_LOR</td>        <td>跨元素执行逻辑“or”（LOR是logical or的缩写）</td>    </tr>    <tr>        <td>MPI_BAND</td>        <td>在元素的位之间执行按位and（BAND是bitwise and的缩写）</td>    </tr>    <tr>        <td>MPI_BOR </td>        <td>在元素的位之间执行按位or（BOR是bitwise OR的缩写）</td>    </tr>    <tr>        <td>MPI_MAXLOC</td>        <td>返回一个最大值以及最大值所在进程的ID</td>    </tr>       <tr>        <td>MPI_MINLOC</td>        <td>返回一个最小值以及最小值所在进程的ID</td>    </tr>     </table></div><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以计算$\pi$值为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> mpi4py <span class="hljs-keyword">import</span> MPI<br><span class="hljs-keyword">import</span> numpy<br><br>comm = MPI.Comm.Get_parent()<br>size = comm.Get_size()<br>rank = comm.Get_rank()<br><br>N = numpy.array(<span class="hljs-number">0</span>, dtype=<span class="hljs-string">&#x27;i&#x27;</span>)<br>comm.Bcast([N, MPI.INT], root=<span class="hljs-number">0</span>)<span class="hljs-comment">#利用Bcast将N发送到之前创建的每个进程。</span><br>h = <span class="hljs-number">1.0</span> / N; s = <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rank, N, size):<span class="hljs-comment">#在各个进程中执行以下循环</span><br>    x = h * (i + <span class="hljs-number">0.5</span>)<br>    s += <span class="hljs-number">4.0</span> / (<span class="hljs-number">1.0</span> + x**<span class="hljs-number">2</span>)<br>PI = numpy.array(s * h, dtype=<span class="hljs-string">&#x27;d&#x27;</span>)<br>comm.Reduce([PI, MPI.DOUBLE], <span class="hljs-literal">None</span>,<br>            op=MPI.SUM, root=<span class="hljs-number">0</span>)<span class="hljs-comment">#利用规约，对各进程中的PI值执行MPI.SUM的求和操作，并把结果放在根进程，也就是最终求得的超越数pi的数值结果</span><br><br>comm.Disconnect()<span class="hljs-comment">#断开与通信域的连接。</span><br></code></pre></td></tr></table></figure><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><p>&emsp;&emsp;有了之前点对点通信以及组通信的概念，我们自然会疑问，很多并行计算任务需要协调更多的进程，并不需要像组通信那样每次都涉及全部进程的任务处理，那么这时如果我们所需要的通信域并不包含全部进程，是否有对应的解决方案呢？答案是肯定的，群（groups）的概念就应运而生。</p><p>关于群的一个重要的组件是MPI_Comm_split，主要的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Comm_split(MPI_Comm comm,<span class="hljs-keyword">int</span> color,<span class="hljs-keyword">int</span> key,MPI_Comm* newcomm)<br></code></pre></td></tr></table></figure><p>这里“<strong>comm</strong>”是预先准备要划分的通信域，而“<strong>color</strong>”则是用于给进程所属子通信域做区分，通俗地讲就是一种颜色对应于一个子通信域，如果“<strong>color</strong>”的关键字没有定义，即“MPI_UNDEFINED”，则该进程不属于任何通信域。“<strong>key</strong>”即为子通信域的ID，既然要划分”<strong>comm</strong>“，就有必要给这些新的通信域一个ID。”<strong>key</strong>“相当于进程的rank，只不过它作用的对象是”<strong>newcomm</strong>“，也就是我们划分出来的新的通信域。下图为MPI_Comm_split原理示意图。</p><center><img src="https://mpitutorial.com/tutorials/introduction-to-groups-and-communicators/comm_split.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;font-size:13px">    MPI_Comm_Split的实现过程（图源：mpitutorial.com）    </div></center><p>MPI_Comm_split只是创建子通讯域的一个最基本的组件，类似的组件还有MPI_Comm_create</p><h1 id="并行编程一些后话"><a href="#并行编程一些后话" class="headerlink" title="并行编程一些后话"></a>并行编程一些后话</h1><p>&emsp;&emsp;这篇博客的初衷只是解决MPI的概念性问题，了解并行计算的基础原理，实际上MPI作为一种成熟的并行接口协议，有着丰富的组件和功能，本文也是借鉴MPItutorial的做法阐述并行编程对于一些入门者可能存在的误区。总结而言，并行编程的要义就是事无巨细地协调预先建立好的计算机任务进程，从而充分发挥集群多核处理器的计算优势。在实际上编程过程中，只要清楚通信域以及与进程之间的关系，在此基础上便能很轻松地实现简单的并行计算，在超算或者集群中完成PC所不能胜任的计算任务。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://mpitutorial.com/tutorials"><span id="1">[1]. https://mpitutorial.com/tutorials</span></a></p><p><a href="https://mpi4py.readthedocs.io/en/stable/tutorial.html"><span id="2">[2]. https://mpi4py.readthedocs.io/en/stable/tutorial.html</span></a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>HPC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>the Quantum Theory of Field</title>
    <link href="/2021/10/10/the-Quantum-Theory-of-Field/"/>
    <url>/2021/10/10/the-Quantum-Theory-of-Field/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="量子场论笔记"><a href="#量子场论笔记" class="headerlink" title="量子场论笔记"></a>量子场论笔记</h1><table width="800" border="1"> <td><p style="font-family:宋体;font-size:15px;width:650px;text-algin:center;">此文内容基于温伯格《the Quantum Theory of Field》一书。作者在得知温伯格先生逝世的消息之后，有感于没有读过其著作的遗憾，遂发愿，希望能从当下已至未来一年间将该学习践行到底。温伯格本人在理论物理上的造诣已是大师之境，他的箴言感召后世，为人敬仰。</p> </td></table><h2 id="第一章-场论的历史"><a href="#第一章-场论的历史" class="headerlink" title="第一章 场论的历史"></a>第一章 场论的历史</h2><p style="text-indent:2em">今天，当我们涉足物理理论世界，四顾坚实的物理建构，这恢弘背后是若干年前物理学家们遇到种种疑难所展现的智慧和勇气。如果不去回顾这段历史很难想象当初的先手们所面临的是何种的困惑。作为物理学史一个重要的节点，量子场论的诞生具有错综复杂的线索，这里面有量子力学和相对论发展的历史，甚至可以说任何在低能下的相对论量子力学都更像场论。</p><h3 id="相对论波动力学"><a href="#相对论波动力学" class="headerlink" title="相对论波动力学"></a>相对论波动力学</h3><p>&emsp;&emsp;相对论量子力学作为量子场论基础的部分曾经给物理学家们带来了相当多的挑战。如果物质粒子和光子一样能用波动力学的手段描述，则对于一个处在$(x, t)$的粒子，其相位应为$2 \pi (\boldsymbol{ k} \boldsymbol{x}+\nu t)$。则为了满足相位的洛伦兹不变性，对应$(\kappa, \nu)$也应该满足洛伦兹变换不变，因此$(\bf{\kappa}, \nu)$ 应与$(\mathrm{\boldsymbol{p}},E)$有相同的速度依赖，由此便给出了德布罗意关系</p><script type="math/tex; mode=display">\boldsymbol k=\mathrm{\boldsymbol p}/h,\quad \nu=E/h.\tag{1}</script><p>在外加矢量场$\bf A$和库伦势$\phi$下，通过对狭义相对论关系$H^2=\mathrm{\boldsymbol p}^2c^2+m^2c^4$ 进行修正替换，则有$(H+e \phi)^{2}-c^{2}(\mathbf{p}+e \mathbf{A} / c)^{2}-m^{2} c^{4}=0$。对自由粒子该方程应有平面波解形式$\exp{\{2\pi i(\boldsymbol k\cdot \boldsymbol x -\nu t)\}}$，对于$(1)$则有</p><script type="math/tex; mode=display">\mathbf{p}=h \boldsymbol{k} \rightarrow-i \hbar \nabla, \quad E=h v \rightarrow i \hbar \frac{\partial}{\partial t}.\tag{2}</script><p>最终我们可以得到所谓克莱因-高登-薛定谔方程</p><script type="math/tex; mode=display">0=\left[\left(i \hbar \frac{\partial}{\partial t}+e \phi\right)^{2}-c^{2}\left(-i \hbar \nabla+\frac{e \mathbf{A}}{c}\right)^{2}-m^{2} c^{4}\right] \varphi(\mathbf{x}, t).\tag{3}</script><p>这个相对论性方程最初由薛定谔给出。我们可以看到，如果代入氢原子定态系统，即$(\mathbf{A}=0,\phi=e/4\pi r)$，在满足一定边界条件下解方程可以得到能量值有</p><script type="math/tex; mode=display">E=m c^{2}\left[1-\frac{\alpha^{2}}{2 n^{2}}-\frac{\alpha^{4}}{2 n^{4}}\left(\frac{n}{\ell+\frac{1}{2}}-\frac{3}{4}\right)+\cdots\right]\tag{4},</script><p>其中$\alpha\equiv e^2/4\pi \hbar c$就是著名的精细结构常数，主量子数$n$和轨道量子数$\ell$满足$0\le\ell\le n-1$。对比索末菲由旧量子理论导出的结果</p><script type="math/tex; mode=display">E=m c^{2}\left[1-\frac{\alpha^{2}}{2 n^{2}}-\frac{\alpha^{4}}{2 n^{4}}\left(\frac{n}{k}-\frac{3}{4}\right)+\cdots\right]\tag{5}.</script><p>这里$k=0,1,\cdots,n$。实际上$(4)$的结果和实验观测相差较大，而索末菲的结果误打误撞，非常巧合地符合精细结构分裂的观测值，它们分别对应$\alpha^4mc^2/12$和$\alpha^4mc^2/32$。薛定谔在得知这个结果之后对自己的推导十分怀疑，搁置了这个结果的发表。数月之后他才意识到这个相对论性的方程在低能近似下的重要意义。与此同时，克莱因等人也独立地得到并发表了同样的结果，所以$(3)$在学界更习惯地称为<strong>克莱因-高登方程</strong>。</p><p>&emsp;&emsp;薛定谔的结果同实验的偏差其实是忽略了电子具有内禀角动量的缘故，后来他正确地意识到这一点。由于电子自旋角动量的存在，自旋轨道产生耦合，从而真正的角动量参数是两者耦合之后的，即所谓总角动量$j=l\pm1/2$。如果将$(4)$中的轨道角动量替换成总角动量，便可以得到同实验观测一致的结果。</p>]]></content>
    
    
    <categories>
      
      <category>Mediation</category>
      
      <category>Knowledge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>群的线性表示论物理所思</title>
    <link href="/2021/07/12/%E7%BE%A4%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%AE%BA%E7%89%A9%E7%90%86%E6%89%80%E6%80%9D/"/>
    <url>/2021/07/12/%E7%BE%A4%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA%E8%AE%BA%E7%89%A9%E7%90%86%E6%89%80%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="物理学中的群论——问题项"><a href="#物理学中的群论——问题项" class="headerlink" title="物理学中的群论——问题项"></a>物理学中的群论——问题项</h1><p style="font-family:楷体; font-size=8px;hight=10px;width=20px"></p> <center><div style="background-color:#F5F5F5;height:70px;width:700px;text-align:left;"><b>此文内容主要基于马中骐老师的《物理学中的群论》一书的自我问答，并穿插近世代数的内容，目标是通过练习总结群论在物理学理论应用中最为核心的概念。</b></div></center> <p style="text-indent:2em">很多物理学家包括杨振宁都笃信我们这个世界为对称性所支配，对称性的数学描述是由伽罗瓦在研究高次代数方程可解性问题的过程中通过建立群论实现的。有关对称性研究的直觉促使物理学家们开始系统学习有关群论的知识，去建立和对称性相关的物理模型。早期，物理学家Weyl和Wigner在有关群论的数学物理研究中对于解释量子力学的一些重要现象取得了长足的进步，后期规范场论的逐步建立确立了对称性研究在理论物理中的重要地位。仅仅在凝聚态物理中，不管是L. Landau所建立的自发对称性破却范式，还是相位因子关于拓扑学在超越Landau范式的拓扑材料理论中的应用，都不可避免地要对相应物理体系做相关对称性分析，更为深刻地揭示了对称性在低能多体领域所展现的本质。这就使得群论学习在提升物理学家理论素养上所体现的必要性。以上描述也是本次学习记录的主要动机。</p><p style="text-indent:2em">群论所探究的内容总和变换相关，具体在物理上处理的对象就是变换算符，所以群的概念的总和对称性联系，因为我们一般所讨论的关于物理上所谓的对称就是用于描述测量的态不依赖时空变换操作（对应观测和）</p><h2 id="群的基本概念："><a href="#群的基本概念：" class="headerlink" title="群的基本概念："></a>群的基本概念：</h2><p style="text-indent:2em"> 群的定义：设群$G$，一般意义的群作为一个集合首先不为空集，即$G\neq\emptyset$，并存在幺元(恒元)$\rm I$，对于群中任意元素$R$，有$\mathrm{I}R=R$，且对于该元素有逆元$R^{-1}$，使得$RR^{-1}=R^{-1}R=\mathrm{I}$。可见恒等变换构成一个只有一个元素的群，它是最简单的群。   </p><p>实际上，对于集合$G$满足一下四个条件即可成群：</p><p>（1）封闭性条件：$RS\in G$，$\forall R,S\in G$。</p><p>（2）元素“乘积”法则满足结合律：$R(ST)=(RS)T$，$\forall R,S,T\in G$。</p><p>（3）存在幺元$\rm I$，满足左乘:$E\in G$，$ER=R, \forall R \in G$。</p><p>（4）任意元素$R$存在逆$R^{-1}$于集合中，满足：$RR^{-1}=R^{-1}R=\mathrm{I}$</p><p>条件中可以看出，定义群的对象是一个非空集合，并存在对应的二元运算（群乘法）。群$G$的元素数目为群的阶，一般记为$g$，一般群的乘法不满足交换律，满足交换律的群即<strong>Abel</strong>群。</p><p>群元的阶，群的指数，陪集，子群，不变子群，共轭类，同态和同构（群元一一对应和一多对应，），群代数</p><p>群的种类，空间群，循环群，置换群，商群</p>]]></content>
    
    
    <categories>
      
      <category>Mediation</category>
      
      <category>Knowledge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初衷</title>
    <link href="/2021/06/16/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/"/>
    <url>/2021/06/16/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9D%E8%A1%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="建立个人博客的初衷"><a href="#建立个人博客的初衷" class="headerlink" title="建立个人博客的初衷"></a>建立个人博客的初衷</h1><p>一直没有写博客的习惯，应该是没有认识到分享记录知识和经验的重要性。很长一段时间自己都是拿来主义，从互联网的知识分享中受益颇多。  应当抽出时间记录自己解决问题和习得的过程。秉承开源精神，是人性之光，我会在日后尽量更新自己在实践终生学习进程中的所思所想，与求知者一同进步。   </p><p>“我们不能根据躯体外貌这些肤浅的官能判断一个人，这并不是说不以貌取人，而是在提问我们如何定义一个确实的人。如果去回答，他需得在时间暴风的裹挟中不被摧毁，并能永恒延续下去。</p><p>如果你害怕死亡，死亡便已降临。</p><p>这个博客的建立参考了B站up主程序羊的<a href="https://www.bilibili.com/video/BV1Yb411a7ty">视频</a>，主题Fluid的选择在于艺术画廊的视觉效果</p><p>。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十九世纪的边沁主义同马尔萨斯人口论</title>
    <link href="/2021/06/16/love/"/>
    <url>/2021/06/16/love/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="16313f953f422f2ca95cbaed5d9e0d6f9c4c4b6175b86be5d1cf2873a5a6b948">148036ef7ff7074153adb0dcbe0701c3ea93c2fee5d636fc0a922545074dba182788f18522bb21fb15edcb9494105dfa6596a48841d0a62601fcdb8194aeefb6e36d3bc6ef9a8ec69fb0349e8ce43708cf7476557ed0d49bddfeb29efcf31ec6d52e48af74f93c34285caacb6bfbae40b1784278f120aa523be66aae735e8c047d0b161580e49618e16f05b9ffd5b116fa7776527050ab4dcd33bd3726f5e5af3ed3a251a10cfde4a1b230aa9c1a9bfae3739ab71af53e23db568d2f25ff2ca849449437f38a91ec1cf459831c37086b78f578d259b9f5e4f92ebd07ab5b471451318663516f3428d4e4d0111e772b76f233a704b6ee82fc77dfb0e5ffcfc41c998e6d3daca0aeb98175de73206d3895f8dd474f4e2bd2c7d9000bd3caa9d9d4eb0ec06d5455c264243d422c55f52d1d7f240855f5059bc63bddcad7c15d7315adbe12a1d520099a16359c03a45580ff5d328811e042e23f0206dbc115ea7dd0ba1055b03da14062a1a05d8b7aecb9aeb63635976308a5875072a5dee4c37737d0eb258cff18682214645f6c3a7947ff</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Feynman diagram</title>
    <link href="/2021/06/16/Feynman-diagram/"/>
    <url>/2021/06/16/Feynman-diagram/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="latex两种费曼图绘制方法"><a href="#latex两种费曼图绘制方法" class="headerlink" title="latex两种费曼图绘制方法"></a>latex两种费曼图绘制方法</h1><p>有必要根据自己的摸索介绍一下latex关于费曼图的绘制方法。Tex排版环境上关于费曼图的绘制有着成熟的解决方案，比如古老的FeynMF/FeynMP或者Axodraw，尤其对于后者，还有可视化绘制工具JaxoDraw。但是二者因为复杂的交互和语法，存在各种痛点。本文旨在引入TiKz-Feynhand费曼图绘制，<strong>讲一讲在latex中费曼图绘制的内在逻辑，以方便有需要者更为便捷的选择，省去探索试错的学习成本</strong>。作为对比，这里介绍2016年更新的AxoDraw2绘制费曼图的方式（FeynMF/FeynMPF过于老旧，这里不做推荐）。  </p><h2 id="两种方式Bubble圈图的语法："><a href="#两种方式Bubble圈图的语法：" class="headerlink" title="两种方式Bubble圈图的语法："></a>两种方式Bubble圈图的语法：</h2><p><strong>AxoDraw2</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;axopicture&#125;(400,60)<span class="hljs-comment">%设置画布大小</span><br><span class="hljs-keyword">\AxoGrid</span>(0,0)(10,10)(20,10)&#123;LightGray&#125;&#123;0.5&#125;<span class="hljs-comment">%网格绘制，给画布绘制坐标，方便绘图定位。其中两边的括号定义起始位置，是画布定义之后之于画布的绝对位置，中间括号定义网格单元，花括号分别定义颜色样式和网格线条粗细。</span><br> <span class="hljs-keyword">\SetWidth</span>&#123;1.0&#125;<br>    <span class="hljs-keyword">\SetColor</span>&#123;Black&#125;<br>    <span class="hljs-keyword">\Line</span>[arrow](0,0)(200,100)<br> <span class="hljs-keyword">\Arc</span>[arrow,arrowpos=0.5,arrowlength=5,arrowwidth=2,arrowinset=0.2](85,-20)(40,30,150)  <span class="hljs-keyword">\Arc</span>[arrow,arrowpos=0.5,arrowlength=5,arrowwidth=2,arrowinset=0.2](85,20)(40,210,330)<span class="hljs-comment">%圆弧，中括号设置相应格式获得不同传播子的样式，最后两个括号设置的是圆心在画布上的位置、半径和起始弧度</span><br>    <span class="hljs-keyword">\Vertex</span>(50,0)&#123;2&#125;<span class="hljs-comment">%顶点，括号和花括号分别代表在画布上的位置和顶点大小的设置</span><br>    <span class="hljs-keyword">\Vertex</span>(120,0)&#123;2&#125;<br><span class="hljs-keyword">\end</span>&#123;axopicture&#125;<br></code></pre></td></tr></table></figure><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"     src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5gxnbywj30je0c8mxz.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">代码对应的AxoDraw2圈图和基本结构示意</div> </center><p><strong>Feynhand</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tikzpicture&#125;[baseline=(a.base)]<span class="hljs-comment">%TiKz的绘制环境</span><br><span class="hljs-keyword">\begin</span>&#123;feynhand&#125;<span class="hljs-comment">%Feynhand的绘制环境</span><br><span class="hljs-keyword">\vertex</span> [dot] (a) at (0,0)&#123;&#125;;<span class="hljs-comment">%定义顶点。其中中括号定义的是顶点的类型，（a）是给顶点标记，（0，0）是顶点的坐标位置，是相对位置。注意这里花括号的有无决定顶点的有无</span><br><span class="hljs-keyword">\vertex</span> [dot] (b) at (2,0) &#123;&#125;;<br><span class="hljs-keyword">\propag</span> [fer] (a) to [half left,edge label = <span class="hljs-built_in">$</span>k<span class="hljs-built_in">$</span>] (b);<span class="hljs-comment">%定义传播子。由于绘图的专一性，图形命令是高度定制的，中括号中可以定义传播子的类型以及各种属性，包括箭头方向以及矢量文字描述</span><br><span class="hljs-keyword">\propag</span> [anti fermion] (a) to [half right] (b);<br><span class="hljs-keyword">\end</span>&#123;feynhand&#125;<br><span class="hljs-keyword">\end</span>&#123;tikzpicture&#125;<br></code></pre></td></tr></table></figure><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"     src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5gxn8a6j30gj09fdfy.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">代码对应的Feynhand圈图</div> </center><p>很明显后者的语法更简洁，下面要介绍本文的重点即相应绘图的逻辑。</p><h2 id="AxoDraw2简介"><a href="#AxoDraw2简介" class="headerlink" title="AxoDraw2简介"></a>AxoDraw2简介</h2><p>AxoDraw2绘制费曼图的逻辑非常容易理解，它的定义环境类似于PythonGUI画布的概念，<code>\begin&#123;axopicture&#125;\end&#123;axopicture&#125;</code>定义的是一个绘制区域（画布），对应的绘制结构就是点和线，<code>\Vertex</code>和<code>\Line</code>，曲线的语法是<code>\Arc</code>，都为大写字母开头。因为是引用画布的概念，我们一般在画布环境下定义网格<code>\AxoGrid</code>，然后依据网格的位置进行作图。这里点和线指令只需要给定两点在网格上的坐标就能在画布上绘制对应的图，Arc的绘制同理，只不过条件上需要坐标和弧度的限制，<a href="http://ctan.math.illinois.edu/graphics/axodraw2/axodraw2-man.pdf">具体格式可以参看手册</a>。因为是画图制图的逻辑，所以AxoDraw2可以方便地使用可视化工具JaxoDraw。不过AxoDraw的痛点在于不能自适应的调节在数学环境中的位置（AxoDraw2 2016的手册给了一种自定义绘制单元的方法可以图像单元实现数学环境中的自适应对齐，但是步骤非常繁琐），虽然上手非常容易，但是对于复杂的费曼图绘制仍然是非常麻烦。</p><p>另外一点是，AxoDraw2要是想直接在PDFLaTex或者XeLaTex上实现图的渲染，还需要在调用axphelp这个脚本实现对.dvi到.ps文件的转换，因为AxoDraw就是基于对.dvi文件编译过程。这额外增加了编译的步骤。</p><h2 id="TiKz-Feynhand简介"><a href="#TiKz-Feynhand简介" class="headerlink" title="TiKz-Feynhand简介"></a>TiKz-Feynhand简介</h2><p>到目前为止，个人觉得TiKz-Feynhand是绘制费曼图的最佳解决方案。它的绘制指令基于TiKz绘制模块。而TiKz在LaTex上的绘图支持是十分完备的，也非常容易上手。实际上TiKz-Feynhand只是在TiKz-Feynman的基础上小小改进，后者由于受限于渲染引擎的使用，只能在LuaLaTex编译环境下才能实现，或者在其他编译环境中调用Lua的编译指令。所以TiKz-Feynman即便语法简单功能丰富，但使用场景不够友好，对于大多数期刊PDFLaTex的编译要求很难进行推广。Feynhand正是为了解决这一问题而诞生，虽然语法简洁程度上有所退让，但是依然非常容易入手，而且可以很方便地与Tex的数学环境相结合，个人以为真正解决了latex绘制费曼图的一些列问题。</p><p>Feynhand的语法环境可以直接在TiKz的绘制环境<code>\begin&#123;tikzpicture&#125;\end&#123;tikzpicture&#125;</code>中使用，这种兼容性决定了TiKz绘制命令基本上都可以在Feynhand的绘制环境<code>\begin&#123;feynhand&#125;\end&#123;feynhand&#125;</code>下实现。由于是定制的格式，Feymhand的绘制逻辑不依赖于画布，而是存粹的根据个人需要给定坐标。设置的坐标是相对位置，而非AxoDraw设置画布的绝对位置。如此我们可以在设定坐标原点的基础上根据正交坐标系任意确定费曼图绘制的区域。对于定制的费曼图顶点、费米线、玻色线等格式可以参看<a href="http://mirrors.ctan.org/graphics/pgf/contrib/tikz-feynhand/tikz-feynhand.userguide.pdf">Feynhand手册</a>。该项目是Max Dohse个人开发，目前基本上的费曼图都能实现，风格定制的选择目前还在开发中，但是现有的功能可以完全满足复杂费曼图的绘制。</p>]]></content>
    
    
    <categories>
      
      <category>Theoritical methods</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>可控核聚变展望</title>
    <link href="/2021/04/11/%E5%8F%AF%E6%8E%A7%E6%A0%B8%E8%81%9A%E5%8F%98%E5%B1%95%E6%9C%9B/"/>
    <url>/2021/04/11/%E5%8F%AF%E6%8E%A7%E6%A0%B8%E8%81%9A%E5%8F%98%E5%B1%95%E6%9C%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一则科技新闻引发的讨论"><a href="#一则科技新闻引发的讨论" class="headerlink" title="一则科技新闻引发的讨论"></a>一则科技新闻引发的讨论</h1><p> 今天看到微信公众号的<a href="https://mp.weixin.qq.com/s/Q4eMa3RJZKQAWoQYeMimpw">一则报道</a>，巧合的是昨天还想了想托卡马克线圈结构的作用，联系到最近回形针的<a href="https://mp.weixin.qq.com/s/z7X3P09zHggwvL_zd4VK5g">视频</a>，有必要说一说可控核聚变的问题。实际上可控核聚变涉及的问题主要在工程技术和材料上的，关于它的理论不过是经典电磁学加狭义相对论的范畴。基本上实现的方式就三种，引力约束大家天天见，惯性约束就是用激光的光子动量把轻核硬挤在一起发生聚变，一般激光用作可控核聚变的点火装置，最后就是也最有希望的就是磁约束，用电磁线圈生成一个磁力紧箍咒。作为中国可控核聚变设备的首选磁约束构型，托卡马克装置主要的构造是三种磁控线圈和一个真空腔室。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"     src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5ikif76j3064076t9s.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">EAST东方超环的红色等离子体。图源WiKi</div> </center><p>三种线圈包括生成环形磁场（安培环路定理）绕腔室的线圈、生成极化磁场以及等离子电流感应电动势的感应线圈（类似于变压器的结构），还有就是控制磁场不均匀导致的粒子漂移和高温粒子相互作用下扩散作用的平行环绕腔室的线圈。第一种线圈一般是超导材料构成，因为需要生成非常强的磁场才能把上亿度高温约束到环形的腔室中；感应线圈兼具控制腔室磁力线分布和加热击穿等离子体的作用，产生的是变化的磁场；平行腔室的线圈对产生的磁场强度要求最小。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"     src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5imm3pgj304q08ndhb.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">环形磁场和极化磁场叠加形成螺旋磁场。图源WiKi</div> </center><p>公众号这个文章里面提到关于可控核聚变实现的另一个技术难点，就是聚变过程产生中子的问题，这东西不带电，没法进行磁约束，普通材料被密集中子轰击只会秒变豆腐渣，一般用和中子不亲和的铪锆等元素构造的腔室可以勉强与之一战。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(128,128,128,.08);"     src="http://tva1.sinaimg.cn/large/006fyIojgy1h5r5ilgtohj309606c0tu.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">托卡马克的线圈和环形腔室的结构。图源WiKi</div> </center><p>这种构造决定了托卡马克很难实现小型化。另一种可控核聚变的实现装置，所谓仿星器，在小型化上就非常有优势，只不过扎花一样的结构决定了在工程实施上的难度，而且控制上的要求更为严格，仿星器不需要感应线圈产生等离子电流，在安全要素上要比托卡马克好很多，但是技术问题相对托卡马克还是太多。</p><p>可控核聚变原料最为重要的就是氘，这东西地球到处都是，但是纯氘的核聚变温度要求更高，所以才会有氘氚混合型和氘氦3型，氚丰度就相对更稀少，它是一种放射性元素，一般核电站压水堆轻水堆会产生，这次日本倾倒的核废水中主要就是氚超标。可控核聚变能实现能效比q＞1，就能抵消点火运行聚变装置消耗的能量，这个ITER预想是做到q=10的程度，不过拖拖踏踏，情况似乎并不乐观。想象一下，在托卡马克巨大的真空腔室中漂浮环绕着比太阳还要耀眼热烈的等离子电浆，一旦启动便可像永动机一样运转，集热器可以源源不断地贪婪地在这电光火石中攫取自然无穷的能量，那一定是人类有史以来最伟大的杰作。民用可控核聚变依赖室温超导体的实现，很多新型的聚变装置也都需要更好的超导材料，所以室温超导是凝聚态材料领域的皇冠，人类命运之所系，室温超导实现之日，便是真正意义上的普罗米修斯盗取天火之时。</p><p>可控核聚变能不能实现关乎下一个一百年人类的命运，离我们并不遥远，所以这事以后热度会越来越高。</p>]]></content>
    
    
    <categories>
      
      <category>Technology Talk</category>
      
      <category>Future</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
